//                                                            Date객체와 날짜
// 날짜를 저장할 수도 있고 날짜와 관련된 메서드도 제공해주는 내장 객체이다.
// Date객체를 활용하면 생성 및 수정 시간을 저장하거나 측정할 수 있고, 현재 날짜를 출력하는 용도로 화룡할 수 있다.
// -----------------------------------------------------------------------------------------------------------------------------------------------

//                                                          객체 생성하기
// new Date()를 호출 하면 새로운 Date 객체가 만들어지는데, 여러가지 형태로 호출할 수 있다.

// -----------------------------------------------------------------------------------------------------------------------------------------------
new Date(); // 인수 없이 호출하면 현재 날짜와 시간이 저장된 Date객체가 반환된다.
let now = new Date();
alert( now ); // 현재 날짜 및 시간이 출력됨

// -----------------------------------------------------------------------------------------------------------------------------------------------
new Date(milliseconds); // UTC 기준인 1970년 01월 01시 0시 0분 0초에서 milliseconds(밀리초) 후의 시점이 저장된 Date객체가 반환된다.
let Jan01_1970 = new Date(0); // 1970년 1월 1일 0시 0분 0초를 나타냄
alert( Jan01_1970 );

let Jan02_1970 = new Date(24 * 3600 * 1000); // 24시간 후인 1970년 1월 2일 0시 0분 0초를 나타냄
alert( Jan02_1970 ); // ! 3600 * 1000는 한시간
// milliseconds를 나타내는 정수는 타임스탬프(timestamp)라고 부른다.
// 타임스탬프를 사용하면 날짜를 숫자 형태로 간편하게 나타낼 수 있고, 특정 날짜가 저장된 Date객체를 만들 수 있다.
// date.getTime() 메서드를 이용해 Date 객체에서 타임스탬프를 추출할 수도 있다.

// 1970년 1월 1일 이전 날짜에 해당하는 타임스탬프 값은 음수이다.
let Dece31_1969 = new Date(-24 * 3600 * 1000); // 31 Dec 1969

// -----------------------------------------------------------------------------------------------------------------------------------------------
new Date(datestring) // 인수가 문자열이라면 자동으로 구분 분석해 날짜를 저장한다.

let date = new Date("2017-01-26");
alert(date); // Thu Jac 26 2017 09:00 GMT+0900 (KST)
// 인수로 시간은 지정하지 않았기 때문에 GMT 자정이라고 가정하고 코드가 실행되는 시간대(timezone)에 따라 출력 문자열이 바뀐다.
// 따라서 GMT보다 9시간 빠른 한국 시간대(KST)가 출력 된다.

// -----------------------------------------------------------------------------------------------------------------------------------------------
new Date(year, month, date, hours, minutes, seconds, ms); // 주어진 인수를 조합해 만들 수 있는 날짜가 저장된 객체가 반환 된다. (지역시간대기준)
// 첫 번째와 두 번째 인수만 필수값이다.
// year는 반드시 네 자리 숫자여야한다. 2013은 가능하고 98은 안된다.
// month는 0(1월)부터 11(12월)사이의 숫자여야 한다.
// date는 일을 나타내는데, 값이 없는 경우 1일로 처리한다.
// hours/minutes/seconds/ms에 값이 없는 경우엔 0으로 처리한다.
new Date(2020, 9, 29, 10, 0, 4, 312); // 2020년 10월 29일 10시 0분 4.312초

// -----------------------------------------------------------------------------------------------------------------------------------------------
//                                                              날짜 구성요소 얻기
// Date 객체의 메서드를 이용하면 연,월,일 등의 값을 얻을 수 있다.

getFullYear(); // 연도(네자리수)를 반환한다.
getMonth(); // 월을 반환한다. (0이상 11이하)
getDate(); // 일을 반환한다. (1이상 31이하)
getHours(); getMinutes(); getSecond(); getMilliseconds(); // 시,분,초,밀리초를 반환한다.
getDay(); // 일요일을 나타내는 0부터 토요일을 나타내는 6까지의 숫자중 하나를 반환한다. ! 한 주의 시작이 일요일임

//(!) getYear()는 두 자릿수 연도를 반환 하는 경우도 있기 때문에 이제는 사용하지는 않지만 작동은하는 메서드이다. FullYear만 사용!!

// 위 메서드들은 모두 현지 시간 기준 날짜 구성요소를 반환한다.
// 위 메서드 이름 get 다음에 UTC를 붙여주면 표준시(UTC+0) 기준의 날짜 구성요소를 반환해준다.
let date = Date();
alert(date.getHours()); // 내가 있는 한국의 시간이 출력
alert(date.getUTCHours()); // 표준시의 시간이 출력됨

getTime(); // 주어진 일시와 1970년 1월 1일 00시 00분 00초 사이의 간격인 타임스탬프(밀리초 단위)를 반환한다.
getTimezoneOffset(); // 현재 시간과 표준 시간의 차이(분)를 반환한다.
alert( new Date().getTimezoneOffset()); // 540, 현재 나의 위치인 한국과 표준시의 차인 540분을 반환한다.

// -----------------------------------------------------------------------------------------------------------------------------------------------
//                                                             날짜 구성요소 설정하기
// 날짜 구성요소를 설정하는 메서드
setFullYear(year, [month], [date]); // []는 옵션
setMonth(month, [date]);
setDate(date);
setHours(hour, [min], [sec], [ms]);
setMinutes(min, [sec], [ms]);
setSeconds(sec, [ms]);
setMilliseconds(ms);
setTime(milliseconds); // 1970년 1월 1일 00:00:00 부터 밀리초 이후를 나타내는 날짜를 설정

// setTime()을 제외한 모든 메서드는 setUTCHours()처럼 표준시에 따라 날짜 구성요소를 설정해주는 메서드가 있다.

// -----------------------------------------------------------------------------------------------------------------------------------------------
//                                                              자동 고침
// Date객체엔 자동 고침(autocorrection)이라는 유옹한 기능이 있는데, 범위를 벗어난 값을 설정하려고 하면 자동 고침이 된다.
let date = new Date(2013, 0, 32); // 2013년 1월 32일, 32일 이라는 날은 없기 때문에 자동으로 2013년 2월 1일로 변경된다.

// 입력받은 날짜 구성 요소가 범위를 벗어나면 초과분은 자동으로 다른 날짜 구성요소에 배분된다.
// 2016년 2월 28일 이틀 뒤 날짜를 구하고 싶다면 답은 3월 2일 혹은 3월 1일(윤년)일 텐데, 2016년이 윤년인지 아닌지는 생각할 필요 없다.
let date = new Date(2016, 1, 28);
date.setDate(date.getDate() + 2);
alert( date ); // 2016년 3월 1일 2016년은 윤년이었네요

// 0이나 음수를 날짜 구성요소에 설정하는 것도 가능하다.
let date = new Date(2016, 0, 2);
date.setData(0); // 일의 최솟값은 1이므로 0을 입력하면 전달의 마지막 날을 출력한다.
alert(date); // 31 Dec 2015

// -----------------------------------------------------------------------------------------------------------------------------------------------
//                                               Date 객체를 숫자로 변경해 시간차 측정하기
// Date객체를 숫자형으로 바꾸면 타임스탬프(밀리초 정수)가 된다.
let date = new Date();
alert(+date); // 1970년 이후로 현재시간 까지의 밀리초를 출력

// 이를 응용하면 날짜에 마이너스 연산자를 적용해 밀리초 기준 시차를구할 수 있다.
let start = new Date(); // 측정시작, 이 코드가 시작할 때 시간이 start에 저장됨

// 여러 작업들 수행 ...
for (let i = 0; i < 10000; i++) {
    let doSomething = i * i * i;
}

let end = new Date(); // 측정종료, 위 코드가 전부 처리되고 이 코드가 시작될 때 시간이 end에 저장됨

alert( `작업을 수행하는데 ${end - start} 밀리초 걸렸습니다.`); // 실제로 컴퓨터가 위 코드를 처리하는 시간을 보여줌

// -----------------------------------------------------------------------------------------------------------------------------------------------
//                                                          Date.now()
// Date객체를 만들지 않고도 시차를 측정하는 방법이 있다.
// 현재 타임스탬프를 반환하는 메서드 Date.now()를 응용하면 된다.
// Date.now()는 메서드 new Date().getTime()과 동일하지만 객체를 만들지 않아 좀더 빠르다
let start = Date.now(); // 측정시작, 이 코드가 시작할 때 시간이 start에 저장됨

// 여러 작업들 수행 ...
for (let i = 0; i < 10000; i++) {
    let doSomething = i * i * i;
}

let end = Date.now(); // 측정종료, 위 코드가 전부 처리되고 이 코드가 시작될 때 시간이 end에 저장됨

// -----------------------------------------------------------------------------------------------------------------------------------------------
//                                                        벤치마크 테스트
// 벤치마크 테스트는 비교 대상을 두고 성능을 비교하여 시험하고 평가할 때 쓰인다.
// 시차를 이용해 cpu가 같은 결과를 가져오는 서로 다른 코드를 처리할 때 시간의 차이를 비교해 더 좋은 성능의 코드를 찾아낸다.
function diffSubtract(date1, date2) {
    return date2 - date1; //  '-' 연산자를 통해 밀리초로 형변환 해서 시간차이를 구함
}

function diffGetTime(date1, date2) {
    return date2.getTime() - date1.getTime(); // getTime()메서드를 호출해 밀리초를 구함
}
// 위 두 함수는 같은 결과를 가져오지만 그 과정은 다르다. 
function bench(f) {
    let date1 = new Date(0); // 1970년 1월 1일 시간
    let date2 = new Date(); // 현재 시간

    let start = Date.now(); // 작업 시작시 시간
    for (let i = 0; i < 100000; i++) f(date1, date2); // 위 두 함수 호출을 10000번 작업함
    return Date.now() - start; // 작업 끝날시 시간을 호출하고 시작시 시간을 뺀다.
}

// 실제로 형변환 없이 바로 함수를 호출하는 getTime()가 훨씬 빠른걸 알 수 있다.
// 하지만 위의 벤치마크 테스트는 멀티 프로세스를 지원하는 운영체제에서는 효과적이지 않다. duffSubtract()를 호출 중일 때 다른 cpu가 다른프로세스를 처리
// 할 수도 있기 때문에
// 좀 더 신뢰 할만한 벤치마크를 만들기 위해서는 위 두 과정을 여러번 번갈아가면서 반복해야한다.
function diffSubtract(date1, date2) {
    return date2 - date1; //  '-' 연산자를 통해 밀리초로 형변환 해서 시간차이를 구함
}

function diffGetTime(date1, date2) {
    return date2.getTime() - date1.getTime(); // getTime()메서드를 호출해 밀리초를 구함
}
// 위 두 함수는 같은 결과를 가져오지만 그 과정은 다르다. 
function bench(f) {
    let date1 = new Date(0); // 1970년 1월 1일 시간
    let date2 = new Date(); // 현재 시간

    let start = Date.now(); // 작업 시작시 시간
    for (let i = 0; i < 100000; i++) f(date1, date2); // 위 두 함수 호출을 10000번 작업함
    return Date.now() - start; // 작업 끝날시 시간을 호출하고 시작시 시간을 뺀다.
}

let time1 = 0;
let time2 = 0;

bench(diffSubtract); // 자바스크립트는 아주 많이 실행된 코드인 hot code를 대상으로 최적화를 수행한다. 그렇기 때문에 본격적으로 벤치마킹하기 전에
bench(diffGetTime);  // 미리 hot code를 만들기 위한 예열용 호출을 한다.

for (let i = 0; i < 10; i++) { // bench()를 10번씩 번갈아가면서 돌려서 좀더 정확한 성능차이를 구함
    time1 += bench(diffSubtract);
    time2 += bench(diffGetTime);
}

// -----------------------------------------------------------------------------------------------------------------------------------------------
//                                                      Date.parse와 문자열
// Date.parse(str)를 이용하면 문자열에서 날짜를 읽어올 수 있다.
// 단, 문자열의 형식이 정해져있는데 YYYY-MM-DDTHH:ss.sssZ 처럼 생겨야만 작동한다.
// YYYY-MM-DD는 연, 월, 일
// 'T'는 구분 기호로 쓰임
// HH:mm:ss.sss는 시:분:초.밀리초
// 'Z'(옵션)는 +-hh:mm 형식의 시간대를 나타냄 'Z'만 있을경우 UTC+0인 표준시간대를 나타낸다.
// 위 조건을 만족하는 문자열을 대상으로 문자열과 대응하는 날짜의 타임스탬프가 반환된다.
// 위 조건을 만족하지 못하면 NaN을 반환한다.

let ms = Date.parse("2012-01-26T13:51:50.417-07:00"); // 2012년 1월 26일 13시 51분 50.417초에서 7시간을 뺀 타임스탬프를 반환한다.
alert(ms); // 13276110417

// Date.parse()는 타임스태프를 반환하기 때문에 이것을 인수로 사용해 새로운 Date객체를 만들 수 있다.
let date = new Date( Date.parse("2012-01-26T13:51:50.417-07:00"));
alert(ms); // Fri Jan 27 2012 05:51:50 GMT+0900(KST) 위 타임스태프의 시간에 맞는 값을 저장한 Date객체를 만들 수 있다.



function getLastDayOfMonth(year, month) {
    let date = new Date(year, month);
    
    if (date.getMonth() < 11) {
       return date.setFullYear(year, month + 1, 0);
    } else {
        return date.setFullYear(year + 1, 0, 0);
    }
}

function getSecondsToday() {
    let today = new Date();
    today.setHours(0, 0, 0, 0);

    return Date.now() - today;
}

function getSecondsToTomorrow() {
    let today = new Date();
    today.setDate(today.getDate() + 1);
    today.setHours(0);

    return today - Date.now;
}

function formatDate(date) {
    let sicha = Date.now() - date.getTime();

    if (date.getTime() > Date.now() - 1000) return `현재`;
    else if (date.getTime() >= Date.now() - 1000 * 60) return `${sicha / 1000}초 전`;
    else if (date.getTime() > Date.now() - 1000 * 60 * 60) return `${sicha / 1000 / 60}분 전`
    else return `${date.getDate()}.${date.getMonth() + 1}.${date.getFullYear().slice(2)} ${date.getHours()}:${date.getMinutes()}`
}