// 자바스크립트 엔진은 도달 가능한 값을 메모리에 유지합니다. 
// 예를 들어
let john = { name: "John"};
// 위 객체는 john이라는 참조를 통해 접근 가능하다.
john = null; 
// 하지만 참조를 null로 덮어쓰면 위 객체는 더이상 도달할 수 없기 때문에 메모리에서 삭제된다.

// 자료구조를 구성하는 요소도 자신이 속한 자료구조가 메모리에 남아있는 동안 대게 도달 가능한 값으로 취급되어 메모리에서 삭제 되지 않는다.
// 객체나 배열 맵과 셋의 요소가 그러한 예다.
let john = { name: "John" }; // 객체를 john에 할당해 참조한다.
let array = [ john ]; // 배열에 john객체를 넣고 array에 할당한다.

john = null; // 참조 john을 null로 덮어씌웠지만 배열의 요소로 여전히 john은 도달가능하기 때문에 지워지지 않는다.

alert(JSON.stringify(array[0])); // { name: "John" }

// 값 뿐만아니라 맵의 키도 가비지 컬렉터의 대상이 되지 않는다.
let john = { name: "John" };

let map = new Map();
map.set(john, "..."); // 객체 john이 map의 키로 사용되었다.

john = null; // 객체 john을 지워도 여전히 map안의 john은 도달가능하기 때문에 지워지지 않음

for (let obj of map.keys()) {
    alert(JSON.stringify(obj));
};

alert(map.size) // 1

//-------------------------------------------------------------------------------------------------------------------------------------------------
//                                                          위크맵
// 이러한 관점에서 위크맵은 맵과 전혀다른 양상을 보여준다.
// 위크맵을 사용하면 키로 쓰인 객체가 가비지 컬렉션의 대상이된다.
// 맵과 위크맵의 차이점은 위크맵의 키가 반드시 객체여야 한다는 것이다.
let weakMap = new WeakMap();
let obj = {};
weakMap.set(obj, "ok"); // 객체를 키로 사용하면 정상작동
weakMap.set("원시형", "notOk") // 문자열을 키로 사용하면 에러가 난다.

// 하지만 맵과 달리 위크맵은 객체를 참조하는 것이 아무것도 없다면 해당 객체는 가비지컬렉션 대상이므로 메모리에서 지워지고 위크맵에서도 지워진다.
let john = { name: "John" };
let weakMap = new WeakMap();
weakMap.set(john, "..."); // 여기 까진 정상작동 하지만

john = null; // 참조값이 지워지는 순간 위크맵의 ["john", "..."]은 지워진다.

// 맵에서 쓸 수 있던 반복작업 메서드 keys(), values(), entries()는 사용할 수 없다.
// get(key), set(key, value), delete(key), has(key)만 사용가능
// 이것은 가비지 컬렉터의 작동방식 때문인데, 가비지 컬렉터의 동작 시점을 알 수 없기 때문이다. 메모리가 언제 삭제될지 모르기 때문에 요소 전체를 대상으로
// 하는 반복작업에 데이터가 있는지 없는지 알 수 없기 때문

//-------------------------------------------------------------------------------------------------------------------------------------------------
//                                                 위크맵을 사용하는경우
// 유스케이스: 추가데이터
// 서드파티 라이브러리와 같은 외부 코드에 속한 객체를 가지고 작업을 해야 한다고 가정해 볼 때 이 객체에 데이터를 추가 하는데 추가해 줄 데이터는 객체가
// 살아있는 동안에만 유효한 상황을 만들고 싶으면 위크맵을 사용하면된다.
// 위크맵에 원하는 데이터를 저장하고 이때 키는 객체를 사용하면 된다. 이렇게 하면 객체가 가비지 컬렉션의 대상이 될 그때에 데이터도 함께 사라진다.
weakMap.set(john, "john의 개인정보");
// 유저 john의 계정 객체를 키로 사용하고 john이 회원탈퇴하거나 죽으면 그 값도 함께 사라진다.
// 위크맵을 사용할 경우 유저가 회원탈퇴해 계정이 쓸모 없어지면 가비지컬렉션의 대상이되어 자동으로 삭제되어 맵을 사용했을 때에 비해 유지보수가 편리하다.
// 그냥 맵을 사용할 경우 직접 유저의 데이터를 지워야 하기 때문

// 유스케이스: 캐싱
// 캐싱(caching)은 시간이 오래 걸리는 작업의 결과를 저장해서 연산 시간과 비용을 절약해주는 기법이다.
// 동일한 함수를 여러 번 호출해야 할 때, 최초 호출시 반환된 값을 어딘가에 저장해 놓았다가 그다음엔 함수를 호출하는 대신 저장된 값을 사용하는게 캐싱의 실례다.

// cache.js
let cache = new Map();

function process(obj) { // 어떤 동작을 하는 함수
    if (!cache.has(obj)) {
        let result = /* 동작 수행 */ obj;
        cache.set(obj, result); // 동작 수행한 결과를 맵에 저장
    }

    return cache.get(obj); // 동작의 결과를 리턴
}

// main.js
let obj = { /* 객체 */};

let result1 = process(obj); // process 함수 호출

let result2 = process(obj); // 동일한 함수를 호출시 함수를 재호출하는 것이 아닌 맵에 저장된 값을 사용한다.

obj = null; // 객체가 쓸모없어지면 객체를 null로 덮어씌운다.

alert(cache.size); // 1, 하지만 맵안의 객체는 지워지지 않음 위크맵을 만들고 위크맵에 객체를 저장하면 객체가 자동으로 삭제된다.

// --------------------------------------------------------------------------------------------------------------------------------------------------
//                                                         위크셋
// 위크셋은 셋과 유사하지만 객체만 저장할 수 있다는 점이 다르다. 원시값은 저장할 수 없음
// 위크셋 안의 객체는 도달 가능할 때만 메모리에서 유지된다. 지워지면 메모리에서 삭제된다.
// 셋과 마찬가지로 위크셋이 지원하는 메서드는 간단하다 반복작업 메서드는 불가능하고 add(), has(), delete() 같은 메서드는 사용 가능하다.
// 위크셋도 위크맵과 마찬가지로 부차적인 데이터를 저장할 때 사용한다. 하지만 위크맵 처럼 복잡한 데이터 대신 예 나 아니오 같은 간단한 답변을 얻는
// 용도로 사용한다.
// 사용자의 사이트 방문 여부를 추적하는 코드 예시
let visitedSet = new WeakSet();

let john = { name: "John"};
let pete = { name: "Pete"};
let mary = { name: "Mary"};

visitedSet.add(john); // john 방문
visitedSet.add(pete); // pete 방문
visitedSet.add(john); // john 재방문
// visitedSet에는 2명의 유저가 저장된다. set은 중복처리

alert(visitedSet.has(john)); // true
alert(visitedSet.has(mary)); // false

john = null; // john을 visitedSet에 null로 비워버려 객체는 가비지컬렉션의 대상이되어 삭제된다.



let messages = [
    {text: "Hello", from: "John"},
    {text: "How goes?", from: "John"},
    {text: "See you soon", from: "Alice"}
];
