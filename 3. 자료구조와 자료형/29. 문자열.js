//                                                          문자열
// 자바스크립트엔 글자 하나만 저장할 수 있는 별도의 자료형이 없다. 텍스트 형식의 데이터는 길이에 상관없이 문자열 형태로 저장된다.
// 자바스크립트에서 문자열은 페이지 인코딩 방식과 상관없이 항상 UTF-16형식을 따른다.

//----------------------------------------------------------------------------------------------------------------------------------------------
//                                                      따옴표
// 작은 따옴표와 큰 따옴표는 기능상 차이가 없다. 그런데 백틱엔 특별한 기능이 있다.
// 표현식을 ${...}로 감싸고 이를 백틱으로 감싼 문자열 중간에 넣어주면 표현식을 문자열 중간에 쉽게 삽입할 수 있다.
// 이런 방식을 템플릿 리터럴(template literal)이라고 부른다.
// 백틱을 사용하면 문자열을 여러 줄에 걸쳐 작성할 수도 있다.
let guestList = `손님:
    * John
    * Pete
    * Mary
`
alert(guestList); // 모달 창에 실제로 여러줄로 표시된다.

//----------------------------------------------------------------------------------------------------------------------------------------------
// 문자열의 길이
// length 프로퍼티엔 문자열의 길이가 저장된다.
alert(`My\n`.length); // 3, \n은 툭수문자 하나로 취급되기 때문에 3

// (!) length는 프로퍼티이다.
//  자바스크립트 이외의 언어를 사용했던 개발자들은 str.length가 아닌 str.legnth()로 문자열의 길이를 알아내려 하지만 length는 함수가 아니고
//  숫자가 저장되는 프로퍼티라는 점에 주의를 해야 한다.

//----------------------------------------------------------------------------------------------------------------------------------------------
//                                                          특정 글자에 접근하기
// 문자열 내 특정위치인 pos에 있는 글자에 접근하려면 [pos]같이 대괄호를 이용하거나 str.charAt(pos)라는 메서드를 호출하면 된다.
let str = `Hello`;

alert(str[0]); // H
alert(str.charAt(0)); // H

alert(str[str.length - 1]); // o, 마지막 글자
// 최근에는 대괄호를 이용하는 방식을 사용한다. charAt은 하위 호환성을 위해 남아있는 메서드

// for..of를 사용하면 문자열을 구성하는 글자를 대상으로 반복 작업을 할 수 있다.
for (let char of "Hello") {
    alert(char); // H -> e -> l -> l -> o
}

//----------------------------------------------------------------------------------------------------------------------------------------------
//                                                              문자열의 불변성
// 문자열은 수정할 수 없다. 따라서 문자열의 중간 글자 하나를 바꾸려고 하면 에러가 발생한다.
let str = "Hi";
str[0] = 'h';
alert( str[0] ); // 동작하지 않는다.

// 그렇기 때문에 이런 문제를 피하려면 완전히 새로운 문자열을 하나 만든 다음, 이 문자열을 str에 할당해야 한다.
let str = "Hi";
str = 'h' + str[i]; // 문자열 전체를 교체
alert( str ); // hi

//----------------------------------------------------------------------------------------------------------------------------------------------
//                                                           대.소문자 변경하기
// 메서드 toLowerCase()와 toUpperCase()는 각각 대문자를 소문자로, 소문자를 대문자로 변경시켜준다.
alert( "Interface".toUpperCase() ); // INTERFACE
alert( "Interface".toLowerCase() ); // interface

// 글자 하나의 케이스만 변경도 가능
alert( "Interface"[0].toLowerCase() ); // interface

//----------------------------------------------------------------------------------------------------------------------------------------------
//                                                             부분 문자열 찾기
// 문자열에서 부분 문자열을 찾는 방법은 여러가지가 있다.

        // str.indexOf(substr, pos)
// 이 메서드는 문자열 str의 pos에서부터 시작해, 부분 문자열을 substr이 어디에 위치하는지를 찾아준다.
// 원하는 부분 문자열을 찾으면 위치를 반환하고 그렇지 않으면 -1을 반환한다.
let str = "Widge id";
alert( str.indexOf('Widget') ); // 0, str은 'Widget'으로 시작함
alert( str.indexOf('widget') ); // -1, indexOf는 대.소문자를 따짐

alert( str.indexOf("id") ); // 1, "id"는 첫 번째 위치에서 발견됨 (W'id'get의 id)
alert( str.indexOf("id", 2) ); // 12, 두 번째인수에 평가를 시작할 위치를 보낼 수 있다. 두 번째 인수 부터 평가해 12번째에 id가 있음

// 문자열 내 부분 문자열 전체를 대상으로 무언가를 하고 싶다면 반복문 안에 indexOf를 사용하면 된다. 반복문이 하나씩 돌 때마다 검색 시작 위치가 갱신되면서
// indexOf가 새롭게 호출된다.
let str = "As sly as a fox, as strong as an ox";
let target = 'as';

let pos = 0;
while (true) {
    let foundPos = str.indexOf(target, pos);
    if (foundPos == -1) break;

    alert( `위치: ${foundPos}` );
    pos = foundPos + 1; // 다음 위치를 기준으로 검색을 이어간다.
}

// (I) str.lastIndexOf(substr, position)
// 위 메서드는 indexOf와 유사한 기능을 하는 메서드이다. 문자열 끝에서부터 부분 문자열을 찾는다는 점만 다르다.

        // str.includes(substr, pos)
// 위 메서드는 str에 부분 문자열 substr이 있는지에 따라 불린값을 반환한다.
// 부분 문자열의 위치 정보는 필요하지 않고 포함 여부만 알고 싶을 때 적합한 메서드이다.

alert( "Widget with id".includes("Widget") ); // true
alert( "Hello".includes("Bye", 2) ); // false, 두 번째 인수를 넘기면 해당 위치부터 부분 문자열을 검색함

        // str.startsWith(), str.endsWith()
// str이 각각 특정 문자열로 시작하는지 여부와 특정 문자열로 끝나는지 여부를 확인할 때 사용할 수 있다. 불린 값을 반환한다.
alert( "Widget".startsWith("Wid") ); // true
alert( "Widget".endsWith("get") ); // true

//----------------------------------------------------------------------------------------------------------------------------------------------
//                                                             부분 문자열 추출하기
        // str.slice(start [,end])
// 문자열의 start부터 end(옵션)까지를 반환한다. 두 번째 인수가 없을 시 start부터 끝까지 반환

let str = "stringify";
alert(str.slice(0, 5)); // strin
alert(str.slice(2)); // ringify

alert(str.slice(-4, -1)); // gif, 음수를 넘기면 문자열 끝에서부터 카운팅을 시작한다. 끝에서 4번째부터 시작해 끝에서 1번째 위치까지

        // str.substring(start [,end])
// start와 end사이에 있는 문자열을 반환한다.
// substring은 slice와 아주 유사하지만 start가 end보다 커도 괜찮다는 데 차이가 있다.
let str = "stringify";
alert(str.substring(2, 6)); // ring
alert(str.substring(6, 2)); // ring

// substring은 음수 인수를 허용하지 않는다. 음수는 모두 0으로 처리한다.

        // str.substr(start [,length])
// start에서 부터 시작해 length개의 글자를 반환한다.
// substr은 끝 위치 대신에 길이를 기준으로 문자열을 추출한다는 점에서 substring가 slice와 차이가 있다.
let str = "stringify";
alert(str.substr(2, 4)); // ring, 두 번째부터 글자 네 개
alert(str.substr(-4, 2)); // gi, 첫 번째 인수가 음수면 뒤에서부터 개수를 센다.

// (I) 어떤 메서드를 선택할까?
// 모두 유용하지만, substr은 오래된 코드이며 slice는 음수를 허용한다는 점에서 substring보다 유연하다.

//----------------------------------------------------------------------------------------------------------------------------------------------
//                                                              문자열 비교하기
// 문자열을 비교할 땐 알파벳 순서를 기준으로 글자기리 비교가 이루어진다. 하지만 추가 규칙이 있음
// 1. 소문자는 대문자보다 항상 크다.
alert('a' > 'Z'); // true
// 2. 발음 구별 기호가 붙은 문자는 알파벳 순서 기준을 따르지 않는다.
// 독일어 처럼 성조가 붙은 특이한 알파벳은 따로취급
// 모든 문자열은 UTF-16을 사용해 인코딩 되는데, 모든 글자가 숫자 형식의 코드와 매칭된다.
// 숫자 형식의 코드 순서에 따라 대문자가 가장 먼저오고 다음 소문자 다음 특수기호 다음 성조가 붙은 알파벳이 온다.



function extractCurrencyValue(str) {
    str = str.slice(1)
    return parseInt(str);
}