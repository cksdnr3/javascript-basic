//                                                      배열
// '키를 사용해 식벽할 수 있는 값'을 담은 컬렉션은 '객체'라는 자료구조를 이용한다.
// 첫 번째 요소, 두 번째 요소, 세 번째 요소 등과 같이 '순서가 있는 컬렉션'이 필요할 땐 '배열'이라는 자료구조를 이용한다.

//----------------------------------------------------------------------------------------------------------------------------------------------
//                                                  배열 선언배열
// 배열 선언 방법
let arr = new Array();
let arr = [];

// 각 배열 요소엔 0부터 시작하는 숫자(index)가 매겨져 있다. 배열 내 특정 요소를 얻고 싶다면 대괄호 안에 순서를 나타내는 index를 넣어주면 된다.
let fruits = ["사과", "오렌지", "자두"];
alert(fruits[0]); // 사과
alert(fruits[1]); // 오렌지
alert(fruits[2]); // 자두

// 같은 방법으로 요소를 수정할 수 있다.
fruits[2] = "배" // ["사과", "오렌지", "배"]

// 같은 방법으로 새로운 요소를 배열에 추가할 수 있다.
fruits[3] = "레몬" // ["사과", "오렌지", "배", "레몬"]

// length를 사용하면 배열에 담긴 요소가 몇 개 인지 알 수 있다.
alert(fruits.length); // 3

// alert를 사용해 요소 전체를 출력할 수 있다.
alert(fruits); // 사과, 오렌지, 자두

// 배열 요소의 자료형에 제약이 없다.
// 원시형인 문자열, 숫자형 뿐만아니라 객체도 배열의 요소로 올 수 있다.

//----------------------------------------------------------------------------------------------------------------------------------------------
//                                                              pop.push와 shift.unshift
// 큐(queue)는 배열을 사용해 만들 수 있는 대표적인 자료구조로, 배열과 마찬가지로 순서가 있는 컬렉션을 저장하는데 사용한다.
// 큐에서 사용하는 주요 연산은 아래와 같다.
// * push - 맨 끝에 요소를 추가한다.
// * shift - 제일 앞 요소를 꺼내 제거한 후 남아있는 요소들을 앞으로 밀어준다. 이렇게 하면 두 번째 요소가 첫 번째 요소가 된다.
// 배열엔 두 연산을 가능케 해주는 내장 메서드 push와 pop이 있다.
// 화면에 순차적으로 띄울 메시지를 비축해 놓을 자료 구조를 만들 때 큐를 사용하는 것처럼 큐는 실무에서 상당히 자주 쓰이는 자료구조이다.

// 배열은 큐 이외에 스택(stack)이라는 자료구조를 구현할 때도 쓰인다.
// 스택에서 사용하는 연산은 아래와 같다.
// * push - 요소를 스택 끝에 집어넣는다.
// * pop - 스택 끝 요소를 추출하다.
// 스택은 이처럼 한쪽 끝에 요소를 더하거나 뺄 수 있게 해주는 자료구조이다.
// 스택은 흔히 카드 한 벌과 비교된다. 쌓여있는 카드 맨 위에 새로운 카드를 더해주거나 빼는 것처럼 스택도 한쪽 끝에 요소를 집어넣거나 추출하기 때문
// 스택을 사용하면 가장 나중에 집어넣은 요소가 먼저 나온다. 이런 특징을 줄여서 후입선출(Last-In-First-Out)이라고 부른다.
// 반면, 큐를 사용하면 먼저 집어넣은 요소가 먼저 나오기 때문에 큐는 선입선출 자료구조라고 부른다.

// 이렇게 처음이나 끝에 요소를 더하거나 빼주는 연산을 제공하는 자료구조를 컴퓨터 과학에선 데큐(deque, Double Ended Queue)라고 부른다.
// 데큐 구조에서 배열 끝에 무언가를 하는 메서드 pop.push
// 1. pop() - 배열 끝 요소를 제거하고, 제거한 요소를 반환한다.
let fruits = ["사과", "오렌지", "배"];
alert(fruits.pop()); // 배열에서 배를 제거하고 제거된 요소를 얼럿창에 띄운다.
alert(fruits); // 사과, 오렌지

// 2. push() - 배열 끝에 요소를 추가한다.
let fruits = ["사과", "오렌지"];
fruits.push("배");
alert(fruits); // 사과, 오렌지, 배

// (I) fruits.push(...)는 fruits[fruits.length] = ... 와 같음

// 데큐 구조에서 배열 앞에 무언가를 하는 메서드 shift.unshift
// 1. shift() - 배열 앞 요소를 제거하고, 제거한 요소를 반환한다.
let fruits = ["사과", "오렌지", "배"];
alert(fruits.shift()); // 배열에서 사과를 제거하고 제거된 요소를 얼럿창에 띄운다.
alert(fruits); // 오렌지, 배

// 2. unshift() - 배열 앞에 요소를 추가한다.
let fruits = ["오렌지", "배"];
fruits.unshift('사과');
alert(fruits); // 사과, 오렌지, 배

//----------------------------------------------------------------------------------------------------------------------------------------------
//                                                              배열의 내부 동작 원리
// 배열은 특별한 종류의 '객체'이다. 배열 arr의 요소를 arr[0]처럼 대괄호를 사용해 접근하는 방식은 객체 문법에서 왔다. 다만 배열은 키가 숫자라는 점만 다르다.
// 배열은 숫자형 키를 사용함으로써 객체 기본기능 외에도 순서가 있는 컬렉션을 제어하게 해주는 특별한 메서드를 제공한다.
// length라는 프로퍼티도 제공한다. 하지만 어쨋든 '배열의 본질은 객체'이다.
// 배열은 객체와 마찬가지로 참조를 통해 복사된다.

// 그런데, 개발자가 배열을 순서가 있는 자료의 컬렉션처럼 다루지 않고 일반 객체처럼 다루면 이런 기법들이 제대로 동작하지 않는다.
let fruits = [];
fruits[9999] = 5; // 배열의 길이보다 훨씬 큰 숫자를 사용해 프로퍼티를 만든다.
fruits.age =25; // 임의의 이름을 사용해 프로퍼티를 만든다.

// 배열은 객체이므로 예시처럼 원하는 프로퍼티를 추가해도 문제가 발생하지 않는다.
// 그런데 이렇게 코드를 작성하면 자바스크립트엔진이 배열을 일반 객체처럼 다루게 되어 배열을 다룰 때만 적용되는 최적화 기법이 동작하지 않아 배열 특유의
// 이점이 사라진다.
// 잘못 사용한 예시
arr.test = 5; // 숫자가 아닌 값을 프로퍼티키로 사용함
arr[0]; arr[100]; // 0과 100만 추가하고 그 사이에 아무런 요소도 없는 경우
arr[1000]; arr[999] // 요소를 역순으로 채움

//----------------------------------------------------------------------------------------------------------------------------------------------
//                                                                  성능
// push와 pop은 빠르지만 shift와 unshift는 느리다.

// 배열 앞 요소에 동작하는 shift.unshift는 다음과 같은 동작을 모두 수행한다.
// 1. 인덱스가 0인 요소를 제거.추가한다.
// 2. 모든 요소를 왼쪽으로.오른쪽으로 이동시킨다. 이때 인덱스가 밀리거나 당겨짐
// 3. length 프로퍼티 값을 갱신한다.
// 그런데 배열에 요소가 많으면 요소가 이동하는데 걸리는 시간이 길고 메모리 관련 연산도 많아진다.

// 그러나 push.pop은 이동을 수반하지 않는다. 그저 끝에서 추가.제거만하고 length프로퍼티의 값을 줄이기만 하면 된다.

//----------------------------------------------------------------------------------------------------------------------------------------------
//                                                              반복문
// for문은 배열을 순회할 때 쓰는 가장 오래된 방법이다. 순회시엔 인덱스를 사용한다.
let arr = ["사과", "오렌지", "배"];
for (let i = 0; i < arr.length; i++) {
    alert(arr[i]); // 사과 -> 오렌지 -> 배
}

// 배열에 적용할 수 있는 또다른 순회 문법 for...of
for (let fruit of fruits) {
    alert(fruit); // 사과 -> 오렌지 -> 배
}
// for..of를 사용하면 현재 요소의 인덱스는 얻을 수 없고 값만 얻을 수 있다. 배열의 요소를 대상으로 반복 작업을 할 땐 for..of를 사용!

// 배열은 객체형에 속하므로 for..in을 사용하는 것도 가능하다.
for (let key in arr) {
    alert(arr[key]); // 사과 -> 오렌지 -> 배
}
// 그런데, for..in은 다음과 같은 특징이 있어 문제가 생길 수 있다.
// 1. for..in 반복문은 모든 프로퍼티를 대상으로 순회한다. 키가 숫자가 아닌 프로퍼티도 순회 대상에 포함된다.
// 브라우저나 기타 호스트 환경에서 쓰이는 객체중, 배열과 유사한 형태를 보이는 유사 배열(array-alike) 객체가 있다. 유사 배열 객체엔 배열처럼 length
// 프로퍼티도 있고 요소마다 인덱스도 붙어 있다. 그런데 여기에 더하여 유사 배열 객체엔 배열과는 달리 키가 숫자형이 아닌 프로퍼티아ㅗ 메서드가 있을 수
// 있다. 유사 배열 객체와 for..in을 함께 사용하면 모든 것을 대상으로 순회가 이루어져, 필요 없는 프로퍼티들도 순회할 수 있다.

// 2. for..in 반복문은 배열이 아니라 객체와 함께 사용할 때 최적화되어 있어 배열에 사용하면 객체에 사용하는 것 대비 10~100배 정도 느리다.
// for..in 자체가 빠르긴해 대부분의 경우 괜찮지만 적절한 곳에 사용하길 바람!

//----------------------------------------------------------------------------------------------------------------------------------------------
//                                                                    length 프로퍼티
// 배열에 무언가 조작을 가하면 length프로퍼티가 자동으로 갱신된다. 
// 배열 내 요소의 개수가 아니라 가장 큰 인덱스에 1을 더한 값이다.
// 배열에 요소가 하나 있지만 이 요소의 인덱스가 아주 큰 경우 배열의 length 프로퍼티도 아주 커진다.
let fruits = [];
fruits[123] = '사과'; 
alert(fruits.length); // 124

// length의 값을 수동으로 증가시키면 아무 일도 일어나지 않는다.
// 그런데 값을 감소시키면 배열이 잘리고 짧아진 배열은 다시 되돌릴 수 없다.
let arr = [1, 2, 3, 4, 5];
arr.length = 2; // 2개만 남기고 잘림
alert(arr); // 1, 2

arr.length = 5;
alert(arr[3]); // undefined, 복구되지 않음

// 이런 특징을 이용해 arr.legnth = 0; 으로 간단하게 배열을 비울 수 있다.

//----------------------------------------------------------------------------------------------------------------------------------------------
//                                                                new Array()
// 대괄호를 사용하는 것보다 까다롭기 때문에 잘사용하지 않는 문법이다.
// 숫자형 인수를 하나 넣어 new Array를 호출하면 배열이 만들어지는데, 이 배열엔 요소가 없는 반면 길이는 인수와 같아진다.
let arr = new Array(2);
alert(arr[0]); // undefined, 요소는 없지만 길이가 2인 배열이 만들어짐
alert(arr.length); // 2
// 따로 값을 지정해 주어야 한다.

//----------------------------------------------------------------------------------------------------------------------------------------------
//                                                        다차원 배열(multidimensional array)
// 배열 역시 배열의 요소가 될 수 있다.
// 다차원 배열은 행렬을 저장하는 용도로 쓰인다.
let matrix = [
    [1, 2, 3],
    [4, 5, 6],
    [7, 8, 9]
];
alert(matrix[1][1]); // 5, 1번째 배열의 1번째 요소 - 중앙값

//----------------------------------------------------------------------------------------------------------------------------------------------
//                                                          toString
// 배열엔 toString 메서드가 구현되어 있어 이를 호출하면 쉼표로 구분한 문자열이 반환된다.
let arr = [1, 2, 3];
alert(arr); // 1,2,3
alert(String(arr) === "1,2,3"); // true

alert([] + 1); // "1"
alert([1] + 1); // "11"
alert([1,2] + 1); // "1,21"

// 배열엔 Symbol.toPrimitive나 valueOf 메서드가 없다. 따라서 위 예시에선 문자열로의 형 변환이 일어 []는 빈 문자열, [1]은 문자열 "1"로 변환된다.