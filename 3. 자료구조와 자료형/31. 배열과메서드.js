//                                      - splice(index, deleteCount, elem1, ... , elemN) -> 제거한 요소로 구성된 배열 반환. 기존 배열 변경o

// 배열의 요소를 지울 때 배열 또한 객체이기 때문에 delete 연산자를 통해 요소를 지울 수 있다.
let arr = ["I", "go", "home"];

delete arr[1];  // 1번 프로퍼티 go를 지운다. delete 연산자는 키에 상응하는 값을 지울 뿐이다.

alert( arr[1] ); // undefined, 0번과 2번은 남아 있고 1번은 값이 할당되지 않았을 뿐 1번프로퍼티는 존재한다. 

alert( arr.length ); // 3,

//빈 공간을 채우며 요소를 지우고 싶다면 splice(index, deleteCount, elem1, ... , elemN)를 통해 가능하다.
// index순서 부터 지우고싶은 요소의 갯수(deleteCount)를 적고 추가하고 싶은 요소(elemN)을 적는다.
let arr = ["I", "study", "Javascript", "right", "now"];

let spliceReturn = arr.splice(0, 3, "Let's", "singing"); // 0번 순서부터 3개의 요소를 지우고 앞 순서 부터 요소 Let's와 singing을 추가한다.

alert( arr ); // ["Let's", "singing", "right", "now"];
alert( arr.length ); // 5 -> 4
alert( spliceReturn ); // ["I", "study", "Javscript"] splice()는 제거한 요소로 구성된 새로운 배열을 반환한다.
// * 지우고싶은 요소의 갯수(deleteCount)가 0이라면 넣고싶은 요소를 넣고싶은 위치에 요소를 지우는 것 없이 추가할 수 있다.
// * 음수 인덱스도 사용가능하다.

//-----------------------------------------------------------------------------------------------------------------------------------------------
//                                                  - slice(start, end) -> 복사한 새로운 배열을 반환한다. 기존 배열 변경x

// slice()는 start순서 부터 (end를 제외한)end순서 까지의 요소를 복사한 새로운 배열을 반환한다.
let arr = ["t", "e", "s", "t"];

alert( arr.slice(1, 3) ); // ["e", "s"], 1번 순서의 요소부터 3번순서를 제외한 순서 까지의 요소를 자른 배열
alert( arr.slice(-2) ); // [s", "t"], *2번째 인자를 전달하지 않으면 끝까지* -2번 순서의 요소부터 끝까지 요소를 자른 배열
// silce()의 인수를 보내지 않고 배열을 그대로 복사할 수도 있다. 기존 배열은 건드리지 않고 기존 배열과 유사한 배열을 만들고자 할 때 자주 사용

//-----------------------------------------------------------------------------------------------------------------------------------------------
//                                               - concat(arg1, arg2...) -> 변경된 배열을 반환

//인수엔 배열 혹은 값이 올 수 있으며 기존 배열에 인수로 보낸 값 혹은 배열을 추가한 배열을 복사해 반환한다.
let arr = [1, 2];

alert( arr.concat([3, 4], 5, 6) ); // [1, 2, 3, 4, 5, 6], 기존 배열에 배열 [3, 4]의 요소를 추가하고 값 5, 6을 추가한 배열을 반환

// 배열에 유사 배열 객체를 concat하면 객체를 통으로 복사해 더한다.
// Symbol.isConcatSpreadable 프로퍼티가 있으면 객체를 배열로 취급한다.
let arr = [1, 2];

let arrayLike = {
    0: "something",
    1: "else",
    [Symbol.isConcatSpreadable]: true,
    length: 1,
};

alert( arr.concat(arrayLike) ); // [1, 2, "something", "else"]

//-----------------------------------------------------------------------------------------------------------------------------------------------
//                                           - forEach(function(item, index, array) {})로 반복작업 하기 - 반환값 없음

// arr.forEach()는 인수로 보낸 함수가 배열 요소의 정보를 매개변수로 받아 각각에 대해 실행할 수 있게 해준다.
["Bilbo", " Gandalf", "Nazgul"].forEach((item, index, array) => {
    alert(`${item} is at index ${index} in ${array}`);
}); // Bilbo is at index 0 in "Bilbo", " Gandalf", "Nazgul" -> Gandalf is at index 1 in "Bilbo", " Gandalf", "Nazgul", Nazgul is at index 2 in "Bilbo", " Gandalf", "Nazgul"
//      가 순서대로 출력된다.
["Bilbo", " Gandalf", "Nazgul"].forEach(function(item, index, array) {
    alert(`${item} is at index ${index} in ${array}`);
}); // 위 화살표 함수와 똑같이 동작함.

//-----------------------------------------------------------------------------------------------------------------------------------------------
//                                                                    - 배열 탐색하기 -

//                                                           indexOf, lastIndexOf, includes
// arr.indexOf(item, from)는 from순서 부터 요소(item)을 찾는다. 요소를 찾으면 해당 요소의 index를 반환하고 찾지 못하면 -1을 반환한다.
// arr.lastIndexOf(item, from)는 indexOf와 동일하게 동작하되 검색을 뒤에서 부터한다.
// arr.includes(item, from)은 from순서 부터 요소(item)을 찾고 찾았을 경우 true를 반환한다.
let arr = [1, 0, false];

alert( arr.indexOf(0) ); // 1, 1번순서에 0이 있음
alert( arr.indexOf(flase) ); // 2, 2번순서에 false가 있음
alert( arr.indexOf(null) ); // -1, 찾지 못함

alert( arr.includes(1) ); // true, 0번 순서에 1이 있기 때문에 true를 반환한다.
// * 위 메서드들은 요소를 찾을 때 완전 항등 연산자 ===을 사용한다. false를 찾을경우 0으로 형변환해서 찾지않고 false그대로를 찾아낸다.
// * 하지만  includes는 NaN도 제대로 처리 한다는 점에서 indexOf, lastIndexOf와 차이점이 있다.
let arr = [NaN];
alert( arr.indexOf(NaN) ); // -1 완전 항등 연산자를 사용해 NaN === NaN을 비교할 경우 자바스크립트는 동작되지 않는다. 그렇기 때문에 NaN을 찾지못해 -1을 반환한다.
alert( arr.includes(NaN) ); // true includes메서드는 NaN도 처리하기 때문에 NaN이 요소로 있는 경우 true를 반환한다.

//-----------------------------------------------------------------------------------------------------------------------------------------------
//                                                                      find와 findIndex
// 객체로 이루어진 배열이 있을 때 특정 조건에 부합하는 객체를 배열 내에서 찾아주는 메서드이다.
let result = arr.find(function(item, index, array) { });
// 1.요소 전체를 대상으로 함수가 순차적으로 호출된다.
// 2.함수가 참을 반환하면 탐색이 중단되고 해당 요소가 반환된다.
// 3.요소를 찾지 못하면 undefined가 반환된다.

let users = [
    {id: 1, name: "John"},
    {id: 2, name: "Pete"},
    {id: 3, name: "Mary"},
];

let user = users.find(item => item.id == 1); // 요소(item)를 매개변수로 요소의 id프로퍼티의 값이 1이 참이면 해당 요소인 객체를 반환해 user에 할당한다.
alert( user.name ); // John
// * item => item.id == N 의 패턴이 주료 사용되며 다른인자(index, array)는 잘 사용되지 않는다.

// findIndex()는 find()와 동일하게 작동하지만 해당 요소의 index를 반환한다.

//-----------------------------------------------------------------------------------------------------------------------------------------------
//                                                                      filter(fn)
// find()는 함수의 반환 값을 true로 만드는 단하나의 요소를 찾는다. but! 반환 값을 true로 만드는 여러개의 요소를 찾고싶다면 filter()를 사용한다.
// filter()는 할당 받은 요소 전체를 배열로 반환한다.
let users = [
    {id: 1, name: "John"},
    {id: 2, name: "Pete"},
    {id: 3, name: "Mary"},
];

let someUsers = users.filter(item => item.id < 3);

alert( someUsers ); // [{id: 1, name: "John"}, {id: 2, name: "Pete"}]

//-----------------------------------------------------------------------------------------------------------------------------------------------
//                                                                - 배열을 변형하는 메서드 -

//                                                      map(function(item, index, array) {})
// 배열 요소 전체를 대상으로 함수를 호출하고 함수 호출 결과를 배열로 반환해줍니다.
let lengths = ["Bilbo", "Gandalf", "Nazgul"].map(item => item.length); // -- 요소들의 길이를 반환하는 메서드
alert( lengths ); // [5, 7, 6]

//-----------------------------------------------------------------------------------------------------------------------------------------------
//                                                                      sort(fn)
// 배열의 정렬기준을 함수로 정의하고 정렬해주는 메서드 정렬기준 함수가 없다면 작은 숫자부터 큰 숫자 순으로 + 사전순으로 정렬한다.
arr.sort((p, c) => p - c); // 대표적인 오름차순 정렬 메서드, 비교할 매개변수 p에 c를 빼서 양수라면 배열의 자리를 바꾼다.
arr.sort((p, c) => c - p); // 내림차순 정렬 메서드

//-----------------------------------------------------------------------------------------------------------------------------------------------
//                                                                      reverse()
// 배열의 요소를 역순으로 정렬시켜 정렬된 배열을 반환하는 메서드이다.
let arr = [1, 2, 3, 4, 5];
arr.reverse();
alert( arr ); // - [5, 4, 3, 2, 1]

//-----------------------------------------------------------------------------------------------------------------------------------------------
// split과 join
//                                                              split(delim, 길이제한)
// 메시지 하나를 여러 수신자에게 보내고 싶을 때 발신자는 수신자를 쉼표로 구분해  보낼 것이다.
// 긴 문자열을 구분자로 기준을 정해 기준에 따라서 문자열을 잘라 배열로 반환하는 메서드이다.
let names = 'Bilbo, Gandlaf, Nazgul'; // -- 쉼표로 구분된 긴 문자열
let arr = names.split(', '); // -- names문자열을 쉼표와 1개의 공백을 기준으로 문자열을 잘라 배열로 만들어 변수 arr에 할당했다.
for (let name of arr) {
    alert( `${name}에게 보내는 메시지` ); // -- 배열 arr의 모든 요소를 변수 name에 담는 for...of 반복문과 arr의 요소를 사용하는 변수 name을 사용해 메세지를 작성했다.
};
// 인자를 빈문자열로 지정하면 문자열을 글자단위로 분리할 수 있다.
// 두번째 인수로 잘라낼 배열의 갯수를 제한할 수 있다.

//-----------------------------------------------------------------------------------------------------------------------------------------------
//                                                                  join(glue)
// split()과 반대 역할을 하는 메서드이다. 인수를 접착제 처럼 사용해 배열 요소를 모두 합친 후 하나의 문자열을 만들어 반환한다.
let arr = ['Bilbo', 'Gandalf', 'Nazgul'];
let str = arr.join(';'); // -- ;을 사용해 배열의 요소를 전부 합친다.
alert( str ); // -- Bilbo;Gandalf;Nazgul

//-----------------------------------------------------------------------------------------------------------------------------------------------
//                                          reduce(function(accumulator, item, index, array) {}, 초깃값)
// accumulator: 이전 함수 호출의 결과, item: 현재 배열의 요소, index: 요소의 위치, array: 배열
// 배열의 요소를 대상으로 반복 작업을 할 수 있다.
// * 반복 작업을 수행하고 작업 결과물을 새로운 배열 형태로 얻으려면 map을 사용해서 활용가능
let arr = [1, 2, 3, 4, 5];
let result = arr.reduce((sum, current) => sum + current, 0);
alert( rseult ); // -- 15
// 초깃값 0이 이전 함수 호출의 결과인 sum에 할당되고 현재 배열의 요소인 current에 1이 할당되어 함수가 실행되어 두 값을 더해 1이반환되고
// 반환된 값이 이전 함수 호출의 결과인 sum에 다시 할당되고 배열의 요소가 끝날 때 까지 반복을 하고 종료한다.
// reduce()는 항상 초깃값을 설정해 주어야 한다.
// reduceRight()는 reduce()와 동일하게 작동하지만 배열 오른쪽 부터 함수를 수행한다.

//-----------------------------------------------------------------------------------------------------------------------------------------------
// Array.isArray로 배열 여부 알아내기

// 배열은 객체이기 때문에 자료형으로 객체와 구분하기 힘들다.
// Array.isArray(value)는 value가 배열이라면 true를 배열이 아니라면 false를 반환한다.
Array.isArray({}); // -- false
Array.isArray([]); // -- true

