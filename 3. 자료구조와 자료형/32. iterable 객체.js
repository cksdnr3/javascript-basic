//---------------------------------------------------------------------------------------------------------------------------------------------
//                                                        iterable(반복가능한) 객체
// for..of 를 사용 할 수 있는 객체를 이터러블이라고 부른다.
// 배열이나 문자열은 내장 이터러블 Symbol.iterator 없이 for..of사용 가능
// 배열은 순서가 있기 때문에 이터러블 가능하지만 일반 객체는 아니다.

//---------------------------------------------------------------------------------------------------------------------------------------------
//                                                            Symbol.iterator
// 일반객체를 순회 하게 하기 위한 특수 내장심볼
// 1. for...of가 시작되면 Symbol.iterator가 호출된다. (일반 객체를 for...of로 반복 할 때 Symbol.iterator가 없으면 에러남)
//    Symbol.iterator는 반드시 iterator(next()가 있는 객체)를 반환 해야한다. next()메서드는 반복에 사용될 값을 만들어 내는 메서드이다.
// 2. 이후 for...of는 iterator객체만을 대상으로 동작한다.
// 3. for...of에 다음 값이 필요 하면, iterator객체의 next()를 호출한다.
// 4. next()의 반환 값은 { done: Boolea, value: any }와 같은 형태이어야 한다. done값이 true일 경우 반복의 종료를 의미 done값이 false일 경우
//    value에 다음 값이 저장된다. 즉 반복문에 반복조건에 false를 넣고 다음값을 저장한다음 반복이 끝나는 조건에 true를 넣어 for...of를 종료시킨다.
let range = { // from부터 to까지의 범위를 지정하고 객체를 순회하고 싶다면?
    from: 1,
    to: 5,
};
// 1. for...of 최초 호출시, Symbol.iterator가 호출된다.
range[Symbol.iterator] = function() {
    // Symbol.iterator는 이터레이터 객체를 반환한다.
    // 2. 이후 for..of는 반환된 이터레이터 객체만을 대상으로 동작하는데, 이때 다음 값도 정해진다.
    return {
        current: this.from,
        last: this.to,

        // 3.for..of 반복문에 의해 반복마다 next()가 호출된다.
        next() {
            // 4.next()는 값을 객체 {done: ... , value: ....} 형태로 반환 해야한다.
            if (this.current <= this.last) {
                return { done: false, value: this.current++ };
            } else {
                return { done: true };
            };
        },
    };
};

for (let num of range) {
    alert(num); // 1, then 2, 3, 4, 5
}

// 이터러블 객체의 핵심은 관심사의 분리에 있다.
// range엔 범위만 지정하고 range[Symbo.iterator]()를 호출해서 만든 이터레이터 객체와 이 객체의 next()메서드를 반복작동해 사용 할 값을 만든다.

//---------------------------------------------------------------------------------------------------------------------------------------------
//                                                          문자열은 이터러블이다

// 배열과 문자열은 가장 광범위 하게 쓰이는 내장 이터러블이다.
for (let char of "test") {
    alert( char ); // -- t, e, s, t 가 차례대로 출력된다.
}
// 서로게이트 쌍에도 잘 동작한다.

//---------------------------------------------------------------------------------------------------------------------------------------------
//                                                              이터레이터를 명시적으로 호출하기

let str = "Hello";

let iterator = str[Symbol.iterator](); // -- Symbol.iterator는 무조건 이터레이터(next()로 동작을 정의해서 반복이 순회하는 객체)를 반환 해야하기 때문에
                                       //    정의하지 않아도 디폴트 이터레이터가 반환된다.

while (true) {
    let result = iterator.next(); // -- next()는 호출하면 디폴트 {done: ..., value: ...} 가 반환된다.
    if (result.done) break; // -- done이 참이면 멈추고
    alert(result.value); // 멈추지 않으면 멈출때 까지 무한반복
}

//---------------------------------------------------------------------------------------------------------------------------------------------
//                                                             이터러블과 유사배열

// 이터러블은 메서드 Symbol.iterator가 구현된 객체이다
// 유사배열객체는 인덱스와 length 프로퍼티가 있어서 배열처럼 보이는 객체이다.
// 문자열은 이터러블 객체이면서 (for..of를 사용 할 수 있음) 유사배열 객체(인덱스와 length프로퍼티를 가지고 있음)이다.
// 이터러블과 유사배열객체는 배열이 아니기 때문에 배열 내장 메서드를 사용 할 수 없다.
// Array.from(obj)는 위 두 객체를 배열로 만들어 배열 내장 메서드를 사용 할 수 있게 해준다.

//---------------------------------------------------------------------------------------------------------------------------------------------
//                                                               Array.from(obj)

// 이터러블과 유사 배열 객체를 배열로 바꿔 배열 내장 메서드를 사용 할 수 있게 해준다.
let arrayLike = {
    0: "Hello",
    1: "World",
    length: 2
};

let arr = Array.from(arrayLike);
alert(arr.pop()); // -- World, 배열 내장 메서드 pop()을 사용 할 수 있음
// Array.from(obj) 인수로 보낸 객체가 이터러블이나 유사 배열인지 조사하고 맞는 경우 새로운 배열을 만들고 객체의 모든 요소를 새롭게 만든 배열에 복사한다.
let arr = Array.from(range) // 위에 이터러블 range
alert(arr); // -- 1, 2, 3, 4, 5

// Array.from(obj, mapFn, thisArg)는 두번째 인수로 함수를 보내면 맵처럼 객체의 모든 요소를 표현식을 거쳐 배열로 만들어준다.
let arr = Array.from(range, num => num * num);
alert(arr); // -- 1, 4, 9, 16, 25 

// 문자열도 Array.from()을 적용 가능하며 split()과 달리 이터러블 속성을 이용해 동작하기 때문에 (for..of를 거쳐 동작하기 때문에)
// 서로게이트 쌍에도 적용이 가능하다. split()은 불가능
// 아래와 같이 기존 내장메서드에서 사용 할 수 없는 것들을 직접 순환하는 메서드를 만들어 사용 할 수 있다.
function slice(str, start, end) {
    return Array.from(str).slice(start, end).join('');
}

let str = "서로게이트 쌍";

alert( slice(str, 1, 3) );
// 기존 slice()에서 자를 수 없는 서로게이트 쌍도 자를 수 있게된다.








