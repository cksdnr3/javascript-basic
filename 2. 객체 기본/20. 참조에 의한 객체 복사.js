//                                                          참조에 의한 객체 복사
// 객체와 원시 타입의 근본적인 차이 중 하나는 객체는 참조에 의해 저장되고 복사된다는 것이다. 원시값은 값 그대로 저장.할당되고 복사되는 반면에 말이다.

let message = "Hello!";
let phrase = message; // 두 개의 독립된 변수에 각각 문자열 Hello!가 저장된다.
// 그러나 객체의 동작방식은 이와 다르다.

// 변수엔 객체가 그대로 저장되는 것이 아니라, 객체가 저장되어 있는 메모리 주소인 객체에 대한 참조 값이 저장된다.
let user = {
    name: "John"
};
// 객체는 메모리 내 어딘가에 저장되고, 변수 user엔 객체를 참조할 수 있는 값이 저장된다.
// 따라서 객체가 할당된 변수를 복사할 땐 객체의 참조 값이 복사되고 객체는 복사되지 않는다.
// 따라서 객체에 접근하거나 객체를 조작할 땐 여러 변수를 사용할 수 있다.
let user = { name: "John" };
let admin = user; // 객체를 복사하는 것이 아닌, 참조주소를 복사함
admin.name = "Pete"; // admin 참조 값에 의해 변경됨
alert(user.name); // Pete, admin참조 값에 의해 변경된 참조는 같은 참조값을 가진 user에도 영향을 미침

//----------------------------------------------------------------------------------------------------------------------------------------------
//                                                          참조에 의한 비교
// 객체 비교 시 동등 연산자 ==와 일치 연산자 ===는 동일하게 동작한다.
// 비교 시 피연산자인 두 객체가 동일한 객체인 경우에 참을 반환한다.

let a = {};
let b = a;
alert(a == b); // true,   두 변수는 같은 객체를 참조한다.
alert(a === b); // true

let a = {};
let b = {};
alert(a == b); // false, 객체의 형태가 같아도 참조가 다르면 다른 객체

//----------------------------------------------------------------------------------------------------------------------------------------------
//                                                             객체 복사, 병합과 Object.assign
// 객체가 할당된 변수를 복사하면 동일한 객체에 대한 참조 값이 하나 더 만들어진다.
// 하지만, 기존에 있던 객체와 똑같으면서 독립적인 객체를 만들고 싶다면 어떻게 해야할까?
// 반복문을 통해 모든 프로퍼티를 순회하며 객체에 할당하는 방법이 있고,
// Object.assign을 사용하는 방법도 있다.
// 문법
Object.assign(dest, src1, src2, srcN)
// 1. 첫 번째 인수 dest는 목표로 하는 객체이다.
// 2. 이어지는 인수 src1 ~ srcN는 복사하고자 하는 객체이다.
// 3. 객체 src1 ~ srcN의 프로퍼티를 dest에 복사한다. dest를 제외한 인수의 프로퍼티 전부가 첫 번째 인수로 복사된다.
// 4. 복사를 마친 dest를 반환한다.

let user = {name: "John"}

let permission1 = { canVuew: true};
let permission2 = { canEdit: true};

Object.assign(user, permission1, permission2); // 이제 user = { name: "John", canView: true, canEdit: true} 가 된다.

// 목표 객체에 동일한 이름을 가진 프로퍼티가 있는 경우엔 기존 값이 덮어씌워진다.
let user = {name: "John"};
Object.assign(user, {name: "Pete"});
alert(user.name); // Pete, John이 Pete로 덮어 씌워짐

// 따라서 Object.assign을 사용하면 아래와 같이 반복문 없이도 간단하게 개체를 복사할 수 있다.
let user = {
    mane: "John",
    age: 30
};
let clone = Object.assign({}, user); // 참조가 다른 객체를 복제함