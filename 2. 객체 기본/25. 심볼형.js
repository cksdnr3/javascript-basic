//                                                                  심볼형
// 자바스크립트는 객체 프로퍼티 키로 오직 문자형과 심볼형만을 허용한다. 숫자형, 불린형 모두 불가능하고 오직 문자형과 심볼형만 가능하다.

//                                                                  심볼(Symbol)
// 심볼은 유일한 식별자(unique identifier)를 만들고 싶을 때 사용한다.
// Symbol()을 사용하면 심볼 값을 만들 수 있다.
let id = Symbol();
// 심볼을 만들 때 심볼 이름이라 불리는 설명을 붙일 수도 있다. 심볼 이름은 디버깅시 아주 유용하다.
let id = Symbol("id"); // 심볼 id에 "id"라는 설명을 붙인 것

// 심볼은 유일성이 보장되는 자료형이기 때문에 설명이 동일한 심볼을 여러 개 만들어도 각 심볼값은 다르다.
// 심볼에 붙이는 설명(심볼 이름)은 어떤 것에도 영향을 주지 않는 이름표 역할만 한다.

// (!) 심볼은 문자형으로 자동 형 변환되지 않는다.
// 자바스크립트에선 문자형으로의 암시적 형 변환이 비교적 자유롭게 일어나는 편이지만 심볼은 예외이다. 심볼형 값은 다른 자료형으로 자동 형 변환되지 않는다.
// 문자열과 심볼은 근본이 다르기 때문에 우연히라도 서로의 타입으로 변환돼선 안된다.
// 심볼을 반드시 출력해야하는 경우엔 .toString()메서드를 명시적으로 호출하면 된다.
let id = Symbol("id");
alert(id.toString()); // Symbol(id)

// symbol.description 프로퍼티를 이용하면 설명만 보여줄 수 있다.
let id = Symbol("id");
alert(id.description); // id

//----------------------------------------------------------------------------------------------------------------------------------------------
//                                                               숨김 프로퍼티
// 심볼을 이용하면 숨김 프로퍼티를 만들 수 있다. 숨김 프로퍼티는 외부 코드에서 접근이 불가능하고, 값도 덮어쓸 수 없는 프로퍼티이다.

// 예를 들어
let user = { // 서드파티 코드에서 가져온 객체라고 가정
    name: "John"
};
let id = Symbol("id");
user[id] = 1;
alert( user[id] ); // 심볼을 키로 사용해 데이터에 접근
// user는 서드파티 코드에서 가지고온 객체이므로 함부로 새로운 프로퍼티를 추가할 수 없다. 그런데 심볼은 서드파티 코드에서 접근할 수 없기 때문에,
// 심볼을 사용하면 서드파티 코드가 모르게 user에 식별자를 부여할 수 있다.

// 다른 예를 들어
// 현재 작성 중인 스크립트, 서드파티 코드, 그리고 또다른 스크립트가 각자 서로의 코드도 모른 채 user를 식별해야 하는 상황인 경우
// 각자의 객체에 Symbol을 이용해 전용 식벽자를 만들어 사용할 수 있다.
// 심볼은 유일성이 보장되므로 우리가 만든 식별자와 또다른 스크립트에서 만든 식별자가 충돌하지 않는다. 심지어 이름이 같더라도
// 만약 심볼 대신 문자열을 통해 식별자를 만들었다면 의도치 않게 값이 덮어 씌워질 수 있다.

//----------------------------------------------------------------------------------------------------------------------------------------------
//                                                          Symbols in a literal
// 객체 리터럴을 사용해 객체를 만든 경우, 대괄호를 사용해 심볼형 키를 만들어야 한다.
let id = Symbol("id");
let user = {
    name: "John",
    [id]: 123 // "id": 123은 안됨
};

//----------------------------------------------------------------------------------------------------------------------------------------------
//                                                          심볼은 for...in에서 배제된다.
// 키가 심볼인 프로퍼티는 for...in 반복문에서 배제된다.
let id = Symbol("id");
let user = {
    name: "John",
    age: 30,
    [id]: 123
};

for (let key in user) alert(key) // name과 age만 출력되고, 심볼은 출력되지 않는다.
alert(user[id]); // 직접 접근만 가능

// Object.keys(user)에서도 키가 심볼인 프로퍼티는 배제된다. 심볼형 프로퍼티 숨기기 원칙 때문에 외부 스크립트나 라이브러리는 심볼형 키를 가진 프로퍼티에 접근하지 못한다.
// 예외로 Object.assign은 키가 심볼인 프로퍼티를 배제하지 않고 객체 내 모든 프로퍼티를 복사한다.

//----------------------------------------------------------------------------------------------------------------------------------------------
//                                                              전역 심볼
// 심볼은 이름이 같더라도 모두 별개로 취급된다. 그런데 이름이 같은 심볼이 같은 개체를 가리키길 원하는 경우도 가끔 있다.
// 전염 식볼 레지스트리는 이런 경우를 위해 만들어졌다. 전역 심볼 레지스트리 안에 심볼을 만들고 해당 심볼에 접근하면, 이름이 같은 심볼이면 항상 동일한 심볼을 반환해준다.
// 레즈스트리 안에 있는 심볼을 읽거나 새로운 심볼을 생성하려면 Symbol.for(key)를 사용하면 된다.
// 이 메서드를 호출하면 이름이 key인 심볼을 반환한다. 조건에 맞는 심볼이 레지스트리 안에 없으면 새로운 심볼을 만든다.

let id = Symbol.for("id"); // 심볼이 존재하지 않으면 새로운 심볼을 만든다.
let idAgain = Symbol.for("id"); // 동일한 이름을 이용해 심볼을 다시 읽는다.
alert( id === idAgain ); // true, 두 심볼은 같다.

//----------------------------------------------------------------------------------------------------------------------------------------------
//                                                         Symbol.keyFor
// 전역 심볼을 찾을 때 사용되는 Symbol.for(key)에 반대되는 메서드도 있다. Symbol.keyFor(sym)를 사용하면 이름을 얻을 수 있다.
let sym = Symbol.for("name"); // 이름을 이용해 심볼을 만듬,읽음
alert( Symbol.keyFor(sym) ); // name, 심볼을 이용해 이름을 얻음
// 검색 범위가 전역 심볼 레지스트리이기 때문에 전역 심볼이 아닌 심볼에는 사용할 수 없다. 전역 심볼이 아닌경우 undefined를 반환한다.

