//                                                           메서드(method)와 this
// 객체는 사용자(user), 주문(order)등과 같이 실제 존재하는 개체(entity)를 표현하고자 할 때 생성된다.
// 사용자는 현실에서 장바구니에서 물건 선택하기, 로그인하기, 로그아웃하기 등의 행동을 한다. 이와 마찬가지로 사용자를 나타내는 객체 user도 특정한
// 행동을 할 수 있다.
// 자바스크립트에선 객체의 프로퍼티에 함수를 할당해 객체에게 행동할 수 있는 능력을 부여해준다.

//----------------------------------------------------------------------------------------------------------------------------------------------
//                                                      메서드 만들기
let user = {
    name: "John",
    age: 30
};
user.sayHi = function() {
    alert("안녕하세요!");
}
user.sayHi(); // 안녕하세요!

// 함수 표현식으로 함수를 만들고, 객체 프로퍼티 user.sayHi에 함수르 할당해 준다.
// 객체에 할당된 함수를 호출하면 인사를 한다. 이렇게 객체 프로퍼티에 할당된 함수를 메서드라고 부른다.

// (I) 객체 지향 프로그래밍
// 객체를 사용하여 개체를 표현하는 방식을 객체 지향 프로그래밍(Object-oriented programming, OOP)이라고 부른다.
// 올바른 개체를 선택하는 방법, 개체 사이의 상호작용을 나타내는 방법등에 관한 의사결정은 객체 지향 설계를 기반으로 이뤄진다.

// 메서드 단축 구문
// 객체 리터럴 안에 메서드를 선언할 때 사용 할 수 있는 단축 문법
user = {
    sayHi: function() {
        alert("Hello");
    }
};
// 위 객체와 아래 객체는 완전히 동일하지는 않지만 거의 유사하게 동작함
user = {
    sayHi() {
        alert("Hello");
    }
};

//----------------------------------------------------------------------------------------------------------------------------------------------
//                                                                  메서드와 this
// 메서드는 객체에 저장된 정보에 접근할 수 있어야 제 역할을 할 수 있다. 대부분의 메서드가 객체 프로퍼티의 값을 활용하기 때문에
// 메서드 내부에서 this키워드를 사용하면 객체에 접근할 수 있다.
// 점 앞의 this는 객체를 나타낸다. 메서드를 호출할 때 사용된 객체
let user = {
    name: "John",
    age: 30,

    sayHi() {
        alert(this.name);
    }
};

user.sayHi(); // John

// this를 사용하지 않고 직접 객체이름을 사용해 참조할 때는 예상치 못한 에러가 발생할 수 있다.
// 해당 객체를 복사해 다른 이름의 변수에 할당한다면 참조했던 객체의 이름을 모두 바꿔주지 않으면 오류가 난다. 유지 보수가 어렵다.

//----------------------------------------------------------------------------------------------------------------------------------------------
//                                                              자유로운 this
// 자바스크립트의 this는 다른프로그래밍 언어의 this와 동작 방식이 다르다. 자바스크립트에선 모든 함수에 this를 사용할 수 있다.
// this값은 런타임에 결정된다. 즉 컨텍스트에 따라 달라진다.
// 동일한 함수라도 다른 객체에서 호출했다면 this가 참조하는 값이 달라진다.

let user = { name: "John" };
let admin = { name: "Admin" };

function sayHi() {
    alert(this.name);
}

user.f = sayHi;
admin.f = sayHi; // this는 점 앞의 객체를 참조하기 때문에 this값이 달라진다.

user.f(); // John
user.f(); // Admin
// obj.f()를 호출했다면 this는 f를 호출하는 동안의 obj이다.

// (I) 객체 없이 호출하기: this == undefined
// 객체가 없어도 함수를 호출할 수 있지만 이런 식의 코드는 대게 작성하지 않는다.
// 엄격모드에선 this엔 undefined가 할당되고, 엄격모드가 아닐 때는 this가 전역 객체를 참조한다.
// 그렇기 때문에 함수 본문에 this가 있으면 객체에서 호출될 것이라고 예상하면 된다.

// (I) 자유로운 this가 만드는 결과
// 다른언어와 달리 자바스크립트에서 this는 런타임에 결정된다. 메서드가 어디서 정의되었는지에 상관없이 this는 점앞의 객체가 무엇인가에 따라 결정된다.
// 함수(메서드)를 하나 만들어 여러 객체에서 재사용할 수 있다는 장점이있지만, 많은 실수를 유발할 수도 있다는 단점이 있다.

//----------------------------------------------------------------------------------------------------------------------------------------------
//                                                          this가 없는 화살표 함수
// 화살표 함수는 일반 함수와 달리 고유한 this를 가지지 않는다. 화살표 함수에서 this를 참조하면, 화살표 함수가 아닌 평범한 외부 함수에서 this값을 가져온다.
let user = {
    firstName: "보라",
    sayHi() {
        let arrow = () => alert(this.firstName);
        arrow();
    }
}
user.sayHi(); // 보라
// 별개의 this가 만들어지는건 원하지 않고, 외부 컨텍스트에 있는 this를 이요하고 싶은 경우 화살표 함수가 유용하다.