//                                                         가비지 컬렉션
// 자바스크립트는 눈에 보이지 않는 곳에서 메모리 관리를 수행한다.
// 원시값, 객체, 함수 등 우리가 만드는 모든 것은 메모리를 차지한다. 더이상 필요없는 것들은 가비지 컬렉션으로 보내 메모리에서 지운다.

//----------------------------------------------------------------------------------------------------------------------------------------------
//                                                      가비지 컬렉션 기준
// 자바스크립트는 도달 가능성(reachability)라는 개념을 사용해 메모리 관리를 수행하낟.
// 도달 가능한 값은 어떻게든 접근하거나 사용할 수 있는 값을 의미한다.

// 아래 예시는 태생부터 도달 가능한 값이기 때문에, 명백한 이유 없이는 삭제되지 않는다.
// 1. 현재 함수의 지역 변수와 매개변수
// 2. 중첩 합수의 체인에 있는 함수에서 사용되는 변수와 매개변수
// 3. 전역 변수
// 이런 값은 루트(root)라고 부른다.

// 루트가 참조하는 값이나 체이닝으로 루트에서 참조할 수 있는 값은 도달 가능한 값이 된다.
// 전역 변수에 객체가 저장되어 있다고 가정해 볼 때, 이 객체의 프로퍼티가 또 다른 객체를 참조하고 있다면, 프로퍼티가 참조하는 객체는 도달 가능한 값이 된다.
// 즉, 전역 변수(항상 도달 가능) -> 객체(루트가 참조하는 객체, 도달 가능) -> 객체의 프로퍼티가 참조하는 객체(체이닝으로 루트에서 참조할 수 있는 객체, 도달 가능)

// 간단한 예시
let user = { name: "John" }; // 전역 변수 user는 객체 { name: "John" }을 참조한다.
user = null; // user의 값을 다른 값으로 덮어 쓰면 참조가 사라진다.
// 참조가 사라지면 객체 { name: "John" }에 접근할 방법도, 참조하는 것도 모두 사라져 가비지 컬렉터는 객체를 메모리에서 삭제한다.

//----------------------------------------------------------------------------------------------------------------------------------------------
//                                                              참조 두개
let user = {
    name: "John"
};
let admin = user;
let user = null;
// 전역 변수 admin과 user는 같은 참조 값이 저장된다. user의 값을 null로 덮어씌워도 {name: "John"}은 admin을 통해 접근 가능하기 때문에 메모리에서 지워지지 않음

//----------------------------------------------------------------------------------------------------------------------------------------------
//                                                          연결된 객체
function marry(man, woman) {
    woman.husband = man;
    man.wife = woman;

    return {
        father: man,
        mother: woman
    }
}

let family = marry({
    name: "John"
}, {
    name: "Ann"
});
// 함수 marry는 매개변수로 받은 두 객체를 서로 참조하게 하면서 결혼시키고, 두 객체를 포함한 새로운 객체를 반환한다.
// 현재 객체는 모두 도달 가능한 상태이다.
delete family.father;
delete family.mother.husband;
// {name: "John"}을 참조하는 것들을 모두 지우면 해당 객체는 도달 가능하지 않아서 메모리에서 지워진다.

// 무언가 나를 참조해야만 도달 가능한 상태에 영향을 준다. 내가 무언가를 참조한다고 해서 도달 가능하다고 볼 수 없다.

//----------------------------------------------------------------------------------------------------------------------------------------------
//                                                          도달할 수 없는 섬
// 위 예시에서 family가 아무것도 참조하지 않도록 하면
family = null;
// John과 Ann은 여전히 서로를 참조하고 있고, 두 객체 모두 외부에서 들어오는 참조를 갖고 있지만, 이것만으로는 충분하지않다.
// 루트의 연결이 사라지면 섬 전체가 도달할 수 없는 상태가 되고 섬을 구성하는 객체 전부가 메모리에서 제거된다.

//----------------------------------------------------------------------------------------------------------------------------------------------
//                                                              내부 알고리즘
// mark-and-sweep이라 불리는 가비지 컬렉션 기본 알고리즘에 대해 알아보자.
// 1. 가비지 컬렉터는 루트 정보를 수집하고 이를 mark(기억) 한다.
// 2. 루트가 참조하고 있는 모든 객체를 방문하고 이것들을 mark한다.
// 3. mark된 모든 객체에 방문하고 그 객체들이 참조하는 객체도 mark한다. 한번 방문한 객체는 전부 mark하기 때문에 같은 객체를 다시 방문하지는 않는다.
// 4. 루트에서 도달 가능한 모든 객체를 방문할 때까지 위 과정을 반복한다.
// 5. mark되지 않은 모든 객체를 메모리에서 삭제한다.

//----------------------------------------------------------------------------------------------------------------------------------------------
//                                                      다양한 최적화 기법
// generational collection(세대별 수집) - 객체를 새로운 객체와 오래된 객체로 나눈다. 객체 상당수는 생성이후 제 역할을 빠르게 수행해 금방 쓸모가 없어지는데,
// 이런 객체를 새로운 객체로 구분한다. 가비지 컬렉터는 이런 객체를 공격적으로 메모리에서 제거한다. 일정 시간 이상동안 살아남은 객체는 오래된 객체로
// 분류하고 가비지 컬렉터가 덜 감시한다.
// incremental collection(점진적 수집) - 방문해야 할 객체가 많다면 모든 객체를 한 번에 방문하고 mark하는데 상당한 시간이 소모된다.
// 가비지 컬렉션에 많은 리소스가 사용되어 실행 속도도 느려진다. 자바스크립트 엔진은 이런 현상을 개선하기 위해 가비지 컬렉션을 여러 부분으로 분리한 다음,
// 각 부분을 별도로 수행한다. 작업을 분리하고 ,변경사항을 추적하는 데 추가 작업이 필요하긴 하지만, 긴 지연을 짧은 지연 여러개로 분산시킬 수 있다는 장점이 있다.
// idle-time collection(유휴 시간 수집) - 가비지 컬렉터는 실행에 주는 영향을 최소화하기 위해 cpu가 유휴 상태일 때에만 가비지 컬렉션을 실행한다.
