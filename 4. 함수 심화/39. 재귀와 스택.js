//                                                          재귀(recursion)와 스택(stack)
// 재귀는 큰 목표 작업 하나를 동일하면서 간단한 작업 여러개로 나눌 수 있을 때 유용한 프로그래밍 패턴이다.
// 목표 작업을 간단한 동작 하나와 목표 작업을 변형한 작업으로 단순화시킬 수 있을 때도 재귀를 사용할 수 있다.

//-------------------------------------------------------------------------------------------------------------------------------------------------
//                                                          두 가지 사고방식
// x를 n제곱해 주는 함수 pow(x, n)를 만드는 두 가지 방식
// 반복적인 사고를 통한 방법
function pow(x, n) {
    let result = 1;
    for (let i = 0; i < n; i++) {
        result *= x;
    };
    return result;
}
alert( pow(2, 3) ); // 8

// 재귀적인 사고를 통한 방법: 작업을 단순화하고 자기 자신을 호출함
function pow(x, n) {
    if (n == 1) {
        return x;
    } else {
        return x * pow(x, n - 1); // n이 1이 될 때 까지 x를 곱한다
    };
}

// 재귀와 반복의 근본적 차이는 작업을 여러개로 나눠 단순화 한다는 것이다. n == 1일 때와 아닐 때를 구분
// n == 1일 때: 모든 절차가 간단해진다. 명확한 결과값을 즉시 도출하므로 이를 재귀의 베이스(base)라고 한다. pow(x, 1)은 x이다.
// n == 1이 아닐 때: pow(x , n)은 x * pow(x, n - 1)으로 표현할 수 있다. 이를 재귀 단계 (recursive step)라고 부른다.
// 여기선 목표 작업 pow(x, n)을 간단한 동작(x를 곱하기)과 목표 작업을 변형한 작업 (pow(x, n - 1))로 분할하였다.
// 즉, pow는 n == 1이 될 때까지 재귀적으로 자신을 호출한다.

// 가장 처음 하는 호출을 포함한 중첩 호출의 최대 개수는 재귀 깊이(recursion depth) 라고 한다. 위 함수 pow의 재귀의 깊이는 n이다.
// 재귀의 깊이는 십만까지는 다루지 못한다.

//-------------------------------------------------------------------------------------------------------------------------------------------------
//                                                      실행 컨텍스트와 스택
// 함수의 내부 동작
// 실행 중인 함수의 실행 절차에 대한 정보는 해당 함수의 실행 컨텍스트(excution context)에 저장된다.
// 실행 컨텍스트는 함수 실행에 대한 세부 정보를 담고 있는 내부 데이터 구조이다. 제어 흐름의 현재 위치, 변수의 현재 값, this의 값 등등...
// 함수 호출 일 회당 정확히 하나의 실행 컨텍스트가 생성된다.
// 함수 안에 중첩 호출이 있을 때 함수 실행 절차
// 현재 함수의 실행이 일시 중지된다. -> 중지된 함수와 연관된 실행 컨텍스트는 실행 컨텍스트 스택(execution context stack)이라는 특별한 자료 구조에 저장된다.
// -> 중첩 호출이 실행된다. -> 중첩 호출 실행이 끝난 이후 실행 컨텍스트 스택에서 일시 중단한 함수의 실행 컨텍스트를 꺼내오고, 중단한 함수의 실행을 다시
// 이어간다.

//-------------------------------------------------------------------------------------------------------------------------------------------------
//                                                            pow(2, 3) 실행 컨텍스트 예제
// pow(2, 3)를 호출하는 순간, 실행 컨텍스트엔 변수 x = 2, n = 3이 저장되고 실행 흐름은 함수의 첫 번째 줄에 위치한다.
// context: {x = 2, n = 3, 위치 = 첫째 줄} -- 현재 실행 컨텍스트
// 위 식으로는 첫 줄 n == 1을 만족하지 못하니 다음 조건 분기로 넘어간다.
// context: {x = 2, n = 3, 위치 = 다섯째 줄} -- 현재 실행 컨텍스트
// 위 함수는 x * pow(x, n - 1)을 반환 하는데, pow(x, n - 1)의 값은 호출해야 알 수 있기 때문에 서브 호출(pow(2, 2))을 만들어야 한다.

// pow(2, 2)를 호출하는 순간, 실행 컨텍스트엔 변수 x = 2, n = 2가 저장되고 실행 흐름은 함수의 첫 번째 줄에 위치한다.
// context: {x = 2, n = 2, 위치 = 첫째 줄} -- 현재 실행 컨텍스트
// context: {x = 2, n = 3, 위치 = 다섯째 줄} -- 이전 실행 컨텍스트  -- 이전 실행 컨텍스트 위에 현재 실행 컨텍스트가 쌓인다.
//  위 식으로는 첫 줄 n == 1을 만족하지 못하니 조건문의 다음 분기로 넘어간다.
// context: {x = 2, n = 2, 위치 = 다섯째 줄} -- 현재 실행 컨텍스트
// context: {x = 2, n = 3, 위치 = 다섯째 줄} -- 이전 실행 컨텍스트
// 위 함수는 x * pow(x, n - 1)을 반환 하는데, pow(x, n - 1)의 값은 호출해야 알 수 있기 때문에 서브 호출(pow(2, 1))을 만들어야 한다.

// pow(2, 1)를 호출하는 순간, 실행 컨텍스트엔 변수 x = 2, n = 1이 저장되고 실행 흐름은 함수의 첫 번째 줄에 위치한다.
// context: {x = 2, n = 1, 위치 = 첫째 줄} -- 현재 실행 컨텍스트
// 위 식은 첫 줄 n == 1을 만족하니 를 반환하고 서브 호출이 모두 끝났기 때문에 함수는 종료되고 반환값 x인 2를 반환한다.
// pow(2, 1)의 값을 알아냈으니 이전 실행 컨텍스트를 꺼내 실행을 이어간다. pow(2, 2)는 2 * pow(2, 1)인 4를 반환하고 pow(2, 3)은 2 * pow(2, 2)인 8을 반환한다.

// 실행 컨텍스트는 메모리를 차지하기 때문에 재귀의 깊이를 늘리면 메모리 사용이 늘어나 기능이 떨어진다.
// 반면 반복문은 함수 첫 호출때 만들어지는 실행 컨텍스트 하나로 해결하기 때문에 메모리 사용이 적음

//-------------------------------------------------------------------------------------------------------------------------------------------------
//                                                      재귀적 순회(recursive traversal)
// 재귀는 재귀적 순회를 구현할 때 사용하면 좋다.
// 재귀적 순회 예제 회사의 임직원 총 급여 합산
let compnay = {
    sales: [{name: "John", salary: 1000,}, {name: "Alice", slary: 1600,}],
    devleopment: {
        site: [{name: "Peter", salary: 2000,}, {name: "Alex", salary: 1800,}],
        internals: [{name: "Jack", salary: 1300,}],},
};
// 이를 반복문으로 해결한다면 company객체를 대상으로 반복을하고 부서를 대상으로 반복을 하는 중첩 반복문이 필요할 것이고 부서안의 작은 부서가 있는 부서는
// 그 안에 또 중첩 반복문이 필요할 것이다. 코드가 매우 지저분 해질 듯?

// 하지만 재귀를 이용하면 좀더 짧고 가독성 좋은 코드를 짤수 있다.
// 재귀의 베이스와 재귀 단계로 나눌 필요가 있다.
// 임직원 "배열"을 가진 단순한 부서 - 간단한 반복문으로 급여합계를 구할 수 있다 - 재귀의 베이스
// N개의 하위 부서를 가진 "객체" - 각 하위 부서에 속한 임직원의 정보를 담은 배열을 얻을 때 까지 재귀 호출을 하고 base를 통해 급여 합산을 얻는다.- 재귀단계
// 재귀 단계에서는 복잡한 작업(여러개의 반복문을 써야하는 작업)은 작은 작업(하위 부서전체를 대상으로 하는 반복문)으로 쪼갤 수 있다.
// 부서의 깊이에 따라 더 작은 작업으로 쪼갤 수 있지만, 결국 마지막엔 베이스를 향해간다.
let compnay = {
    sales: [{name: "John", salary: 1000,}, {name: "Alice", slary: 1600,}],
    devleopment: {
        site: [{name: "Peter", salary: 2000,}, {name: "Alex", salary: 1800,}],
        internals: [{name: "Jack", salary: 1300,}],},
};

function sumSalaries(department) {
    if (Array.isArray(department)) { // 인수가 배열이면 반복문 실행 = 객체로 묶인 큰 부서가 배열로 묶인 하위 부서로 쪼개질 때 까지 재귀한 후 베이스로 옴
        return department.reduce((prev, current) => prev + current.salary, 0);
    } else {
        let sum = 0;
        for (let subdep of Object.value(department)) {
            sum += sumSalaries(subdep) // 재귀 호출로 각 하위 부서 임직원의 급여 총합을 구함 재귀 단계
        }
        return sum;
    }
}

// 알고리즘 순서
// 객체 company를 인수로 보내 호출한 순간 context: {위치 : 첫째 줄}
// company는 배열이 아니기 때문에 첫째 줄 조건문을 만족하지 못하고 조건문 다음 분기로 넘어간다. context: {sum = 0, 위치: 다섯째 줄}
// company객치의 값을 대상으로 반복문을 실행한다.
// 변수 subdep에 sales부서의 값이 담기고 sales부서를 대상으로 재귀호출 한다.
// sales 부서의 값은 배열이기 때문에 베이스로가 부서의 급여 합을 반환해 변수 sum에 더한 후 할당한다.
// 다음 development부서의 값은 객체이기 때문에 다시 재귀단계로 온다. development의 값을 상대로 반복문이 실행된다.
// development의 sites부서의 값을 대상으로 재귀호출을 한다.
// sites부서의 값은 배열이기 때문에 베이스로가 부서의 급여 합을 반환해 변수 sum에 더한 후 할당한다.
// 다음 internals부서의 값을 대상으로 재귀호출을 한다.
// internals부서의 값은 배열이기 때문에 베이스로가 부서의 급여 합을 반환해 변수 sum에 더한 후 할당한다.
// 더 이상 호출할 변수가 없기 때문에 함수가 종료된다.

// 즉, 위 함수는 객체를 만나면 서브 호출을 하는 재귀단계로 가고 배열을 만나면 더 이상의 서브 호출이 없고 바로 값을 계산하는 베이스 단계로 가는 규칙이 있다.

//-------------------------------------------------------------------------------------------------------------------------------------------------
//                                                          재귀적 구조
// 재귀적으로 정의된 자료구조인 재귀적 자료 구조는 자기 자신의 일부를 복제하는 형태의 자료 구조입니다.

// 연결리스트: 재귀적 구조를가진 특별한 자료 구조
// 객체를 어딘가에 저장할 때 가장먼저 떠오르는 것은 배열일 것이다.
// 하지만 배열은 삭제,삽입에 들어가는 비용이 많다.
// arr.(un)shift()를 사용하면 배열의 순서를 재정의 해야하고 그렇지 않고 사용할 수 있는 것은 arr.push(),pop() 뿐이다.
// 연결리스트(linked list)는 빠르게 삭제,삽입이 가능한 자료구조이다.

// 연결리스트의 요소는 객체와 프로퍼티{value, next}를 조합해 정의할 수 있따.
// next: 다음 연결리스트 요소를 참조하는 프로퍼티 다음요소가 없다면 null을 저장하면 된다.
let list = {
    value: 1,
    next: {
        value: 2,
        next: {
            value: 3,
            next: {
                value: 4,
                next: null
            }
        }
    }
};
// 혹은
let list = { value: 1 };
list.next = { value: 2 };
list.next.next = { value: 3 };
list.next.next = { value: 4 };
list.next.next.next = null;

// 리스트 쪼개기
let secondList = list.next.next; // 쪼개고 싶은 부분을 할당하면 뒷 부분은 자동으로 할당된다.
list.next.next = null; // 복사해서 할당해주고 내껀 삭제해줘야함
// 리스트 합치기
list.next.next = secondList; // 원하는 곳에 새로운 리스트를 할당함
// 리스트 삽입
list = { value: "new item", next: list}; // 리스트 맨앞에 프로퍼티를 추가함
// 리스트 중간요소 제거
list.next = list.next.next; // 이전 요소의 next를 다음요소의 next로 할당하면 이전요소의 next가 탈락됨
// 탈락된 요소는 다른 곳에 저장하지 않으면 메모리에서 지워짐

// 연결 리스트는 아래와 같은 기능을 더해 개선할 수 있다.
// 프로퍼티 prev를 추가해 이전 요소로 쉽게 이동할 수 있다.
// 프로퍼티 tail을 추가해 리스트 마지막요소를 참조할 수 있다. 마지막요소를 추가하거나 삭제하면 tail도 갱신해 줘야함.

