//                                                  setTimeout고 setInterval을 이용한 호출 스케줄링
// 일정 시간이 지난 훙 ㅔ원하는 함수를 예약 실행(호출)할 수 있게 하는 것을 호출 스케줄링(scheduling a call)이라고 한다.

// 호출 스케줄링을 구현하는 방법 두 가지
// * setTimeout을 이용해 일정 시간이 지난 후에 함수를 실행하는 방법
// * setInteravl을 이용해 일정 시간 간격을 두고 함수를 실행하는 방법

//-------------------------------------------------------------------------------------------------------------------------------------------------
//                                                  setTimeout
let timerId = setTimeout(func|code, delay, arg1, arg2, ...argN);

// func|code : 실행하고자 하는 코드로, 함수 또는 문자열 형태이다. 대게는 이 자리에 함수가 들어간다. 문자열은 하위 호환성을 위해 남겨둔 것.
//             함수의 반환 값이 아닌 코드의형태
// delay : 실행 전 대기 시간으로, 단위는 밀리초(1/1000 초)이며 기본값은 0이다.
// arg1, arg2, argN : 함수에 전달할 인수들이다.

// 예시
function sayHi(who, phrase) {
    alert(who + '님' + phrase);
}
setTimeout(sayHi, 1000, "홍길동", "안녕하세요."); // 홍길동 님, 안녕하세요.가 1000밀리초(1초) 후에 실행된다.

// setTimeout의 첫 번째 인수가 문자열이면 자바스크립트는 이 문자열을 이용해 함수를 만든다. - 문자열로 함수를 작성해 setTimeout을 이용할 수 있음
setTimeout("alert('안녕하세요)", 1000);
// 하지만 이렇게 문자열을 사용하는 방법은 추천하지 않는다. 되도록 다음 예시와 같이 익명 화살표 함수를 사용하도록!
setTimeout(() => alert('안녕하세요'), 1000);

// (I) 함수를 실행하지 말고 넘기세요
setTimeout(sayHi(), 1000); // 잘못된 코드
// setTimeout은 함수의 참조 값을 받도록 정의되어 있는데 saiHi()를 인수로 전달하면 함수 실행 결과가 전달되어 버린다.

//-------------------------------------------------------------------------------------------------------------------------------------------------
//                                                      clearTimeout으로 스케줄링 취소하기
// setTimeout을 호출하면 타이머 식별자(timer identifier)가 반환된다. 스케줄링을 취소하고 싶을 땐 이 식별자를 사용하면 된다.
let timerId = setTimeout("anycode...");
clearTimeout(timerId);

// 아래 예시는 함수 실행을 계획해 놓았다가 중간에 마음이 바뀌어 계획해 놓았던 것을 취소한 상황을 코드로 표현하고 있다.
// 예시를 실행해도 스케줄링이 취소되었기 때문에 아무런 변화가 없다.
let timerId = setTimeout(() => alert("아무런 일도 일어나지 않는다."), 1000);
alert(timerId); // 타이머 식별자

clearTimeout(timerId);
alert(timerId); // 위 타이머 식별자와 동일함 (취소 후에도 식별자의 값은 null이 되지 않는다.)

// 위 코드를 실행하면 브라우저 환경에선 타이머 식별자가 숫자라는 걸 알 수 있다. 호스트 환경마다 타이머 식별자의 자료형이 다를 수 있다.

//-------------------------------------------------------------------------------------------------------------------------------------------------
//                                                             setInterval
// setInterval의 문법은 setTimeout과 동일하다.
// 문법:
let timerId = setInterval(func|code, delay, arg1, arg2, argN);

// setTimeout이 함수를 단 한 번만 실행하는 것과 달리 setInterval은 함수를 주기적으로 실행하게 만든다.
// 함수 호출을 중단하려면 clearInterval(timerId)을 사용하면 된다.

// 예시:
let timerId = setInterval(() => alert('째깍'), 2000); // 2초 간격으로 메시지를 보여줌
setTimeout(() => {clearInterval(timerId); alert('정지');}, 5000); // 5초 후에 정지

// (I) 모달 창이 떠 있더라도 타이머는 멈추지 않는다.
// 대부분의 브라우저는 모달 창이 떠 있는 동안에도 내부 타이머를 멈추지 않는다.
// 위 예시를 실행하고 첫 번째 모달 창이 떳을 때 몇 초간 기다렸다가 창을 닫으면 두 번째 모달 창이 바로 나타나는 것을 확인할 수 있다.

//-------------------------------------------------------------------------------------------------------------------------------------------------
//                                                          중첩 setTimeout
// 무언가를 일정 간격을 두고 실행하는 방법에는 크게 2가지가 있다.
// setInterval을 이용하는 방법과 중첩setTimeout을 이용하는방법

let timerId = setInterval(() => alert("째깍"), 2000); // 아래의 setTimeout을 사용하는 것과 동일한 동작을 한다.

let timerId = setTimeout(function tick() {
    alert("째깍");
    timerId = setTimeout(tick, 2000); // (*)
}, 2000);

// (*)로 표시한 줄의 실행이 종료되면 다음 호출을 스케줄링한다.
// 중첩 setTimeout을 이용하는 방법은 setInterval을 사용하는 방법보다 유연하다. 호출 결과에 따라 다음 호출을 원하는 방식으로 조정해 스케줄링 할 수 있다.
// 5초 간격으로 서버에 요청을 보내 데이터를 얻는다고 상황에 서버 과부하가 걸리면 요청을 10초로 유동적으로 증가시킬 수 있다.

// cpu소모가 많은 작업을 주기적으로 실행하는 경우도 setTimeout을 재귀 실행하는 방법이 유용하다. 작업에 걸리는 시간에 따라 다음 작업을 유동적으로 계획할 수 있다.
// 중첩setTimeout을 이용하는 방법은 지연 간격을 보장하지만 setInterval은 이를 보장하지 않는다.
// 즉, setTimeout은 동작이 끝난 후 setTimeout을 호출하기 때문에 동작이 끝난 후 딜레이가 시작되지만,
// setInterval은 setInterval을 호출함과 동시에 딜레이가 시작되어 동작이 끝나는 시간과 상관없이 다음 동작이 시작된다.

// setInterval
let i = 1;
setInterval(function() {
    func(i++); // func(i++)가 끝나기도 전에 다음 func(i++)가 호출될 수 있음 setInterval이 호출됨과 동시에 타이머가 시작됨
}, 100);

// 중첩 setTimeout
let i = 1;
setTimeout(function run() {
    func(i++);  // 동작이 실행되고 끝마친 후에
    setTimeout(run, 100); // setTimeout을 재귀호출함, 동작이 끝난후에 타이머가 시작됨
})

// (I) 가비지 컬렉션와 setInterval.setTimeout
// setInteval이나 setTimeout에 함수를 넘기면, 함수에 대한 내부 참조가 새롭게 만들어지고 이 참조정보는 스케줄러에 저장된다. 따라서 해당 함수를 참조하는
// 것이 없어도 setInterval과 setTimeout에 넘긴 함수는 가비지 컬렉션의 대상이되지 않는다.
// setInterval의 경우는, clearInteval이 호출되면 함수에 대한 참조가 사라진다.
// 그런데 이런 동작 방식에는 부작용이 있는데, 외부 렉시컬 환경을 참조하는 함수가 있다고 가정해보면, 함수가 메모리에 남아있는 동안엔 외부 변수 역시 메모리
// 에 남아있는다. 그런데 이렇게 되면 실제 함수가 차지하는 공간보다 더 많은 메모리를 차지하게 된다.
// 스케줄링이 필요 없어진 함수는 아무리 작더라도 clearInterval 하자!!

//-------------------------------------------------------------------------------------------------------------------------------------------------
//                                                          대기 시간이 0인 setTImeout
// 대기시간을 0으로 설정하면 func을 가능한 한 빨리 실행할 수 있다. 다만, 이때 스케줄러는 현재 실행 중인 스크립트의 처리가 종료된 이후에 스케줄링한 함수를 실행한다.
// 이런 특징을 이용하면 현재 스크립트의 실행이 종료된 직후에 원하는 함수가 실행될 수 있게 할 수 있다.

// 예시를 실행하면 얼럿창에 Hello와 World가 순서대로 출력된다.
setTimeout(() => alert("World")); // 내가 실행하고싶은 함수
alert("Hello"); // 현재 실행중인 스크립트의 함수

// 예시에서 첫 번째 줄은 0밀리초 후에 함수를 호출하기 라는 할 일을 계획표에 기록 해주는 코드이다. 그런데 스케줄러는 현재 스크립트의 실행이 종료되고
// 나서야 계획표에 어떤 할 일이 적혀있는지 확인하므로 Hello가 먼저, World은 그다음에 출력된다.

// (I) 브라우저 환경에서 실제 대기 시간은 0이 아니다.
// 브라우저는 HTML5표준에서 정한 중첩 타이머 실행 간격 관련 제약을 준수한다.
// 해당 표준엔 다섯 번째 중첩 타이머 이후엔 대기 시간을 최소 4밀리초 이상으로 강제해야 한다. 라는 제약이 명시되어 있다.

// 예시를 보며 이해해보자
let start = Date.now();
let times = [];

setTimeout(function run() {
    times.push(Date.now() - start); // 이전 호출이 끝난 시점과 현재 호출이 시작된 시점의 시차를 배열에 넣음
})