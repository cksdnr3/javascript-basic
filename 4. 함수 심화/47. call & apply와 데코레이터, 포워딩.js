//                                                         call/apply와 데코레이터, 포워딩
// 자바스크립트는 함수를 다룰 때 탁월한 유연성을 제공한다. 함수는 이곳저곳 전달되 수 있고, 객체로도 사용될 수 있다.
// 이번 챕터에선 함수 간에 호출을 어떻게 포워딩(forwarding)하는지, 함수를 어떻게 데코레이팅(decorating)하는지에 대해 알아본다.

//-------------------------------------------------------------------------------------------------------------------------------------------------
//                                                          코드 변경 없이 캐싱 기능 추가하기
// CPU를 많이 잡아먹지만 결과는 안정적인 함수 slow(x)가 있다고 가정해 봅시다. 결과가 안정적이라는 말은 x가 같으면 호출 결과도 같다는 것을 의미합니다.
// slow(x)가 자주 호출된다면, 결과를 어딘가에 저장(캐싱)해 재연산에 걸리는 시간을 줄이고 싶을 것입니다.
// 아래 예시에선 slow() 안에 캐싱 관련 코드를 추가하는 대신, 래퍼 함수를 만들어 캐싱 기능을 추가할 예정입니다.
function slow(x) {
    // CPU 집약적인 코드가 있다고 가정...
    return x;
}

function cachingDecorator(func) {
    let cache = new Map();

    return function(x) {//          ------------------------------------------------
        if (cache.has(x)) {         // cache에 해당 키가 있으면                     ㅣ
            return cache.get(x);    // 대응하는 값을 cache에서 읽어온다.            ㅣ
        }                           //                                             ㅣ 캐싱 로직을 가진 래퍼 함수
                                    //                                             ㅣ 
        let result = func(x);       // 그렇지 않은 경우엔 func를 호출하고,     <- 본래 함수, 본래함수를 캐싱 로직을 가진 래퍼함수로 감싼 모양

        cache.set(x, result);       // 그 결과를 캐싱(저장)하고,                     ㅣ
        return result;              // func반환 값을 반환한다.                       ㅣ
    }                               // ---------------------------------------------
}

slow = cachingDecorator(slow); // slow 캐싱 래퍼를 함수 slow에 할당함
slow(1); // slow(1)이 저장됨
slow(1); // 동일한 결과를 함수 계산없이(cpu소모 없이) 값을 출력

// cachingDecorator같이 인수로 받은 함수의 행동을 변경시켜주는 함수를 데코레이터라고 부른다.
// 모든 함수를 대상으로 cachingDecroator를 호출 할 수 있는데, 이때 반환되는 것은 캐싱 래퍼이다. 함수에 cachingDecorator를 적용하기만 하면 캐싱이 가능한
// 함수를 원하는 만큼 구현할 수 있기 때문에 데코레이터 함수는 아주 유용하게 사용된다.
// 캐싱 관련 코드를 본 함수 코드와 분리할 수 있기 때문에 함수의 코드가 간결해진다는 장점도 있다.

// cachingDecorator(func)를 호출하면 래퍼 함수인 function(x)가 반환된다. 래퍼 function(x)는 func(x)의 호출 결과를 캐싱 로직으로 감싼다.
// 함수 slow는 래퍼로 감싼 이전이나 이후나 동일한 일을 수행하고, 행동 양식에 캐싱기능이 추가된 것 뿐이다.

// slow 본문을 수정하는 것 보다 독립된 래퍼 함수 cachingDecorator를 사용할 때 생기는 이점을 정리하면 다음과 같다.
// * cachingDecorator를 재사용할 수 있다. 원하는 함수는 인수로 보내 캐싱 로직을 사용가능
// * 캐싱 로직이 분리되어 slow자체의 복잡성이 증가하지 않는다.
// * 필요하다면 여러 개의 데코레이터를 조합해서 사용할 수도 있다.

//-------------------------------------------------------------------------------------------------------------------------------------------------
//                                                          func.call를 사용해 컨텍스트 지정하기
// 위에서 구현한 캐싱 데코레이터는 객체 메서드에 사용하기엔 적합하지 않는다.
// 메서드에서 this를 사용할 경우 참조 할 수 없기 때문
// func.call(context, arg1, arg2, ...argN)은 첫 번째 인수로 참조할 this를 보내면 그것을 고정시킬 수 있다.

let worker = {
    someMethod() {
        return 1;
    },

    slow(x) {
        // CPU 집약적 코드가 있다고 가정
        return x * this.someMethod();
    }
};
function cachingDecroator(func) {
    let cache = new Map();
    return function(x) {
        if (cache.has(x)) {
            return cache.get(x);
        }
        let result = func(x);
        cache.set(x, result);
        return result;
    };
}
alert(worker.slow(1)); // 기존 메서드는 잘 동작
worker.slow = cachingDecorator(worker.slow);
alert(worker.slow(2)); // 캐싱 데코레이터 적용시 에러발생!

// worker.slow의 반환 값 중 this가 참조하는 컨텍스트가 데코레이팅하면서 worker에서 undefined로 바뀌었다. (객체 없이 호출하면 this == undefined)
let func = worker.slow;
func(2); // undefined, 위에 예시와 같은 원리/ 변수 func에 메서드의 참조를 할당하지만, func는 객체 worker소속이 아님

// 캐싱 데코레이터를 아래와 같이 수정하면 오류를 막을 수 있음
function cachingDecorator(func) {
    let cache = new Map();
    return function(x) {
        if (cache.has(x)) {
            return cache.get(x);
        }
        let result = func.call(this, x); // --> 런타임 시 this가 .앞의 객체로 고정됨
        cache.set(x, result);
        return result;
    };
}
worker.slow = cachingDecorator(worker.slow);
worker.slow(2); // 정상 동작

// 명확한 이해를 돕기 위해 this가 어떤 과정을 거쳐 전달되는지 자세히 살펴보자
// 1. 데코레이터를 적용한 후에 worker.slow는 래퍼 function (x) {}가 된다.
// 2. worker.slow(2)를 실행하면 래퍼는 2를 인수로 받고, this = worker가 된다. (.앞의 객체)
// 3. 결과가 캐시되지 않은 상황이라면 func.call(this, x)에서 현재 this와 인수를 원본 메서드에 전달한다.

// (I) 객체 없이 호출하기: this == undefined
// 객체가 없어도 함수를 호출할 수 있지만 이런 식의 코드는 대게 작성하지 않는다.
// 엄격모드에선 this엔 undefined가 할당되고, 엄격모드가 아닐 때는 this가 전역 객체를 참조한다.
// 그렇기 때문에 함수 본문에 this가 있으면 객체에서 호출될 것이라고 예상하면 된다.

// (I) 자유로운 this가 만드는 결과
// 다른언어와 달리 자바스크립트에서 this는 런타임에 결정된다. 메서드가 어디서 정의되었는지에 상관없이 this는 점앞의 객체가 무엇인가에 따라 결정된다.
// 함수(메서드)를 하나 만들어 여러 객체에서 재사용할 수 있다는 장점이있지만, 많은 실수를 유발할 수도 있다는 단점이 있다.

//-------------------------------------------------------------------------------------------------------------------------------------------------
//                                                          여러 인수 전달하기
// 지금까진 인수가 x하나 뿐이었기 때문에 cache.set(x, result)로 결과를 저장하고 cache.get(x)로 저장된 결과를 불러오기만 하면 됐다.
// 그런데 이제부턴 인수가 여러개이고, 이인수들을 넘겨 호출한 결과를 기억해야한다. 기존의 맵은 단일 키만 받지만 말이다.

// 해결 방법은 여러가지가 있따.
// 1. 복수 키를 지원하는 맵과 유사한 자료 구조 구현하기.
// 2. 중첩 맵을 사용하기. (max, result)쌍 저장은 cache.seg(min)에 저장하고 result는 cache.get(min).get(max)로 얻능 방법
// 3. 두 값을 하나로 합치기. 맵의 키로 문자열 "min,max"를 사용한다. 여러 값을 하나로 합치는 코드는 해싱함수(hashing function)에 구현해 유연성을 높인다.

// 세 번째 방법만으로 충분하기 때문에 이 방법을 사용해 코드를 수정해 보겠다.
// 여기에 더하여 func.call(this, x)를 func.call(this, ...arguments)로 교체해, 래퍼 함수로 감싼 함수가 호출 될 때 복수 인수 넘길 수 있도록 한다.

// (I)  function test(...a) {} -> 함수 선언시 ...은 나머지 매개변수, 여러 인자를 받아 배열로 합친다.
//      test(...a) -> 함수 호출시 ...은 인수 전개문법, 이터러블을 받아 쪼개서 펼친다.
//      arguments -> 모든 인수에 접근가능한 이터러블 가능한 유사배열 객체

let worker = {
    slow(min, max) {
        // cpu집약적 코드가 있다고 가정...
        return min + max;
    }
};

function cachingDecorator(func, hash) { // 데코레이팅 할 함수 func와 해싱을 도와줄 hash함수를 인수로 받음
    let cache = new Map();
    return function() {
        let key = hash(arguments);      // 이 함수의 모든 인수를 이터러블로 보내 해싱한 값을 key에 할당함
        if (cache.has(key)) {           // 키가 있으면
            return cache.get(key);      // 이에 해당하는 값을 반환
        }
        let result = func.call(this, ...arguments); // 없으면 이 함수의 모든 인수를 전개해서 보낸후 반환 값을 result에 할당함. context는 this로 고정

        cache.set(key, result); // 맵에 func의 결과를 key에다 저장함
        return result;          // func의 결과를 반환함
    }
}

function hash(args) {
    return args[0] + ',' + args[1]; // 이터러블로 받은 arguments(모든 인수 이터러블)을 문자열로 바꿈
}

worker.slow = cachingDecorator(worker.slow, hash); // 데코레이터 설정

alert(worker.slow(3, 5)); // 인수 3, 5를 보내 worker.slow를 캐싱하면서 동작을 반환받음

//-------------------------------------------------------------------------------------------------------------------------------------------------
//                                                              func.apply

// 그런데 여기서 func.call(this, ...arguments) 대신, func.apply(this, arguments)를 사용해도 된다.
func.apply(context, args);

// apply는 func의 this를 context로 고정해주고, 유사 배열 객체인 args를 인수로 사용할 수 있게 해준다.
// call과 apply의 문법적 차이는 call이 복수 인수를 따로따로 받는 대신 apply는 인수를 유사 배열 객체로 받는다는 점뿐이다.

// 둘의 약간의 차이점이 있다.
// * call은 전개 문법 ...을 분해 해 call에 전달한다.
// * apply는 오직 유사 배열 형태의 args만 받는다.

// 때문에 인수가 이터러블 형태라면 clal을, 유사 배열 형태라면 apply를 사용하면 된다.
// 배열같이 이터러블이면서 유사 배열인 객체엔 둘 다를 사용할 수 있는데, 대부분의 자바스크립트 엔진은 내부에서 apply를 최적화하기 때문에 apply를 사용하는 것이
// 좀 더 빠름
// 이렇게 컨텍스트와 함께 인수 전체를 다른 함수에 전달하는 것을 콜 포워딩(call forwarding)이라고 한다.

// 가장 간단한 형태의 콜 포워딩은 다음과 같다
let wrapper = function() {  // 래퍼
    return func.apply(this, arguments); // 본 함수의 결과 값, 래퍼안에 다른 동작을 넣으면 본 함수의 결과 값을 데코레이팅하는 코드를 작성하는 것
};
// 이런 식으로 외부에서 wrapper를 호출하면, 기존 함수인 func를 호출하는 것과 명확하게 구분할 수 있다.

//-------------------------------------------------------------------------------------------------------------------------------------------------
//                                                          메서드 빌리기

// 위에서 구현한 해싱 함수를 개선해 봅시다.
function hash(args) {
    return args[0] + "," + args[1];
}

// 현재 코드로는 args는 2개의 인수만 다룰 수 있다. 요소의 개수에 상관없이 실행시는 방법은 무엇이 있을까?
// 가장 간단한 방법은 arr.join(glue)를 사용하는 것이다.
// 하지만 넘겨받은 인수 arguments는 유사배열객체이지 배열이아니기 때문에 join메서드를 사용할 수 없다.

// 그런데 아래와 같은 방법을 사용하면 유사배열객체에서 배열관련 메서드를 빌릴 수 있다.
function hash() {
    alert( [].join.call(arguments) ); // 1, 2
}
hash(1, 2);
// 이러한 트릭을 메서드 빌리기(method borrowing)이라고 부른다.

// 일반 배열에서 join메서드를 빌려오고 ([].join), call을 사용해 arguments를 컨텍스트로 고정한 후 join메서드를 호출하는 방식이다.
// 이게 어떻게 가능할까요?
// 네이티브 메서드 arr.join의 내부 알고리즘은 아주 간단하기 때문이다.
// arr.join의 알고리즘
// 1. glue가 첫 번째 인수가 되도록한다. 인수가 없으면 ","가 첫 번째 인수가 된다.
// 2. 결과는 빈 문자열이 되도록 초기화한다.
// 3. this[0]을 결과에 덧붙인다.
// 4. glue와 this[1]을 결과에 덧붙인다.
// 5. glue와 this[2]을 결과에 덧붙인다.
// 6. 모든 항목이 추가될 때까지 이 일을 반복한다.
// 7. 결과를 반환한다.

// 잘모르겠

//-------------------------------------------------------------------------------------------------------------------------------------------------
//                                                   데코레이터와 함수 프로퍼티

// 함수 또는 메서드를 데코레이터로 감싸 대체하는 것은 대체적으로 안전하다. 그런데 원본 함수에 func.calledCount등의 프로퍼티가 있으면
// 데코레이터를 적용한 함수에선 프로퍼티를 사용할 수 없으므로 안전하지 않다. 함수에 프로퍼티가 있는 경우엔 데코레이터 사용에 주의해야 한다.

// 위 예시에서 함수 slow에 프로퍼티가 있었다면 cachingDecorator(slow)호출 결과인 래퍼엔 프로퍼티가 없다.

// 몇몇 데코레이터는 자신만의 프로퍼티를 갖기도 한다. 데코레이터는 함수가 얼마나 많이 호출되었는지 세거나 호출 시 얼마나 많은 시간이 소모되었는지 등의
// 정보를 래퍼의 프로퍼티에 저장할 수 있다.

// 함수 프로퍼티에 접근할 수 있게 해주는 데코레이터를 만드는 방법도 있다. 그런데 이걸 구현하려면 proxy라는 특별한 객체를 사용해 함수를 감싸야 한다.